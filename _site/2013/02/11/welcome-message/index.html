<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Welcome message - Habla computing Blog</title>
    <link rel="stylesheet" href="/assets/css/app.css">
    <link rel="shortcut icon" type="image/png" href="/favicon.png" />
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Welcome message | Habla computing Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Welcome message" />
<meta name="author" content="Juan Manuel Serrano" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Think of information systems, Web 2.0 apps, games, e-learning, e-commerce, and the rest of e-* applications. Certainly, these application domains differ significantly in several respects, but can we find some commonalities? We do think so: they deal directly with people; they are deeply concerned with their needs for communication, collaboration and coordination; they all can be regarded as social apps. If we have a look to their functional requirements, we will invariably find people playing different roles, saying things to one another, seeing what is happening, generating and consuming information, and so forth; moreover, we will also notice how the application must take into account different normative concerns: permissions to do something, commitments endorsed by particular role players, monitoring rules, etc. How are these applications developed nowadays? Programmers mainly use object- and functional-oriented programming languages, such as Java, C#, Scala, Haskell, etc. Yet, functions and objects are quite apart from the kinds of social abstractions we just mentioned above. Similarly, factories, facades, monads, etc., are alien to domain experts and non-IT people. The likely result: a daunting amount of accidental complexity leaked into the code. Clearly, if we want to strive for purely functional code, i.e. software which directly encode the functional requirements of the application, we have to raise the level of abstraction supported by the programming language. Towards social-oriented programming ... In Habla Computing we are building Speech, a domain-specific programming language for implementing the domain logic of social apps. Speech offers the programmer computational counterparts of social concepts such as roles, speech acts, interaction contexts, commitments, permissions, and the like, which aim at closing the gap between natural-language functional requirements and executable code. The net result of this higher-level of abstraction is a drastic reduction in lines-of-code, development times and cost, as well as a significant increase in quality. Of course, we are not alone in this quest for functional purity: the current landscape abounds with domain-specific proposals that aim at simplifying the implementation of business processes, vertical social networks, etc. Two features, however, distinguish Speech from BPMS, social networking engines, and other domain-specific technologies. First, Speech is not confined to niche domains; do your functional requirements deal directly with people? If so, you can profit from Speech, regardless of the kind of social process supported by the application. Second, Speech is a language for programmers; it is neither a modeling language for business analysts, nor a suite of tools that cope with each functional concern separately. Certainly, we aim at bridging the gap between non-IT people and programmers, and we claim Speech designs to be directly understandable by functional experts. But programmers need a self-sufficient, cohesive and expressive language. Thus, besides being a domain-specific technology, Speech has been designed as a programming language which takes into account every functional concern in a modular and cohesive way. Moreover, in order to foster adoption of Speech in the programming language community, we&#39;ve decided to offer Speech as an embedded DSL, rather than as a stand-alone implementation. ... embedded in Scala! There are several very good languages which enable an embedded implementation strategy, but we finally chose Scala. We especially like its mix of functional and object-oriented features, and love its new experimental ones: macros turned out essential for us. This blog will allow us to unveil the major challenges we faced in implementing Speech, and how Scala helped us to solve them. We strive for functional-programming purity in our codebase, so the title of this blog also appeals to that leitmotiv. In this regard, topics that will eventually arise include: coping with updates of immutable objects within generic contexts; dealing with references to evolving immutable objects; etc. Some of these issues lead us to develop general-purpose libraries that we&#39;ve planned to open-source. We are open to suggestions and recommendations for improvements, and any other form of collaboration. Your feedback is really important to us. We will also use this blog to announce the release of our products. We are working against the clock to launch the beta release of the Speech interpreter in the following weeks. So, we expect to contact you again very soon. Finally, this blog will also give us the opportunity to advertise our participation in different events. One of these events will take place on 10th-13th April at Cambridge, UK: join us at Code Generation 2013!" />
<meta property="og:description" content="Think of information systems, Web 2.0 apps, games, e-learning, e-commerce, and the rest of e-* applications. Certainly, these application domains differ significantly in several respects, but can we find some commonalities? We do think so: they deal directly with people; they are deeply concerned with their needs for communication, collaboration and coordination; they all can be regarded as social apps. If we have a look to their functional requirements, we will invariably find people playing different roles, saying things to one another, seeing what is happening, generating and consuming information, and so forth; moreover, we will also notice how the application must take into account different normative concerns: permissions to do something, commitments endorsed by particular role players, monitoring rules, etc. How are these applications developed nowadays? Programmers mainly use object- and functional-oriented programming languages, such as Java, C#, Scala, Haskell, etc. Yet, functions and objects are quite apart from the kinds of social abstractions we just mentioned above. Similarly, factories, facades, monads, etc., are alien to domain experts and non-IT people. The likely result: a daunting amount of accidental complexity leaked into the code. Clearly, if we want to strive for purely functional code, i.e. software which directly encode the functional requirements of the application, we have to raise the level of abstraction supported by the programming language. Towards social-oriented programming ... In Habla Computing we are building Speech, a domain-specific programming language for implementing the domain logic of social apps. Speech offers the programmer computational counterparts of social concepts such as roles, speech acts, interaction contexts, commitments, permissions, and the like, which aim at closing the gap between natural-language functional requirements and executable code. The net result of this higher-level of abstraction is a drastic reduction in lines-of-code, development times and cost, as well as a significant increase in quality. Of course, we are not alone in this quest for functional purity: the current landscape abounds with domain-specific proposals that aim at simplifying the implementation of business processes, vertical social networks, etc. Two features, however, distinguish Speech from BPMS, social networking engines, and other domain-specific technologies. First, Speech is not confined to niche domains; do your functional requirements deal directly with people? If so, you can profit from Speech, regardless of the kind of social process supported by the application. Second, Speech is a language for programmers; it is neither a modeling language for business analysts, nor a suite of tools that cope with each functional concern separately. Certainly, we aim at bridging the gap between non-IT people and programmers, and we claim Speech designs to be directly understandable by functional experts. But programmers need a self-sufficient, cohesive and expressive language. Thus, besides being a domain-specific technology, Speech has been designed as a programming language which takes into account every functional concern in a modular and cohesive way. Moreover, in order to foster adoption of Speech in the programming language community, we&#39;ve decided to offer Speech as an embedded DSL, rather than as a stand-alone implementation. ... embedded in Scala! There are several very good languages which enable an embedded implementation strategy, but we finally chose Scala. We especially like its mix of functional and object-oriented features, and love its new experimental ones: macros turned out essential for us. This blog will allow us to unveil the major challenges we faced in implementing Speech, and how Scala helped us to solve them. We strive for functional-programming purity in our codebase, so the title of this blog also appeals to that leitmotiv. In this regard, topics that will eventually arise include: coping with updates of immutable objects within generic contexts; dealing with references to evolving immutable objects; etc. Some of these issues lead us to develop general-purpose libraries that we&#39;ve planned to open-source. We are open to suggestions and recommendations for improvements, and any other form of collaboration. Your feedback is really important to us. We will also use this blog to announce the release of our products. We are working against the clock to launch the beta release of the Speech interpreter in the following weeks. So, we expect to contact you again very soon. Finally, this blog will also give us the opportunity to advertise our participation in different events. One of these events will take place on 10th-13th April at Cambridge, UK: join us at Code Generation 2013!" />
<link rel="canonical" href="http://localhost:4000/2013/02/11/welcome-message/" />
<meta property="og:url" content="http://localhost:4000/2013/02/11/welcome-message/" />
<meta property="og:site_name" content="Habla computing Blog" />
<meta property="og:image" content="http://localhost:4000/img/default-post.svg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-02-11T18:39:24+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://localhost:4000/img/default-post.svg" />
<meta property="twitter:title" content="Welcome message" />
<script type="application/ld+json">
{"@type":"BlogPosting","image":"http://localhost:4000/img/default-post.svg","headline":"Welcome message","dateModified":"2013-02-11T18:39:24+01:00","datePublished":"2013-02-11T18:39:24+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2013/02/11/welcome-message/"},"author":{"@type":"Person","name":"Juan Manuel Serrano"},"description":"Think of information systems, Web 2.0 apps, games, e-learning, e-commerce, and the rest of e-* applications. Certainly, these application domains differ significantly in several respects, but can we find some commonalities? We do think so: they deal directly with people; they are deeply concerned with their needs for communication, collaboration and coordination; they all can be regarded as social apps. If we have a look to their functional requirements, we will invariably find people playing different roles, saying things to one another, seeing what is happening, generating and consuming information, and so forth; moreover, we will also notice how the application must take into account different normative concerns: permissions to do something, commitments endorsed by particular role players, monitoring rules, etc. How are these applications developed nowadays? Programmers mainly use object- and functional-oriented programming languages, such as Java, C#, Scala, Haskell, etc. Yet, functions and objects are quite apart from the kinds of social abstractions we just mentioned above. Similarly, factories, facades, monads, etc., are alien to domain experts and non-IT people. The likely result: a daunting amount of accidental complexity leaked into the code. Clearly, if we want to strive for purely functional code, i.e. software which directly encode the functional requirements of the application, we have to raise the level of abstraction supported by the programming language. Towards social-oriented programming ... In Habla Computing we are building Speech, a domain-specific programming language for implementing the domain logic of social apps. Speech offers the programmer computational counterparts of social concepts such as roles, speech acts, interaction contexts, commitments, permissions, and the like, which aim at closing the gap between natural-language functional requirements and executable code. The net result of this higher-level of abstraction is a drastic reduction in lines-of-code, development times and cost, as well as a significant increase in quality. Of course, we are not alone in this quest for functional purity: the current landscape abounds with domain-specific proposals that aim at simplifying the implementation of business processes, vertical social networks, etc. Two features, however, distinguish Speech from BPMS, social networking engines, and other domain-specific technologies. First, Speech is not confined to niche domains; do your functional requirements deal directly with people? If so, you can profit from Speech, regardless of the kind of social process supported by the application. Second, Speech is a language for programmers; it is neither a modeling language for business analysts, nor a suite of tools that cope with each functional concern separately. Certainly, we aim at bridging the gap between non-IT people and programmers, and we claim Speech designs to be directly understandable by functional experts. But programmers need a self-sufficient, cohesive and expressive language. Thus, besides being a domain-specific technology, Speech has been designed as a programming language which takes into account every functional concern in a modular and cohesive way. Moreover, in order to foster adoption of Speech in the programming language community, we&#39;ve decided to offer Speech as an embedded DSL, rather than as a stand-alone implementation. ... embedded in Scala! There are several very good languages which enable an embedded implementation strategy, but we finally chose Scala. We especially like its mix of functional and object-oriented features, and love its new experimental ones: macros turned out essential for us. This blog will allow us to unveil the major challenges we faced in implementing Speech, and how Scala helped us to solve them. We strive for functional-programming purity in our codebase, so the title of this blog also appeals to that leitmotiv. In this regard, topics that will eventually arise include: coping with updates of immutable objects within generic contexts; dealing with references to evolving immutable objects; etc. Some of these issues lead us to develop general-purpose libraries that we&#39;ve planned to open-source. We are open to suggestions and recommendations for improvements, and any other form of collaboration. Your feedback is really important to us. We will also use this blog to announce the release of our products. We are working against the clock to launch the beta release of the Speech interpreter in the following weeks. So, we expect to contact you again very soon. Finally, this blog will also give us the opportunity to advertise our participation in different events. One of these events will take place on 10th-13th April at Cambridge, UK: join us at Code Generation 2013!","url":"http://localhost:4000/2013/02/11/welcome-message/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-140060849-1"></script>
<script>
  window['ga-disable-UA-140060849-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-140060849-1');
</script></head>

<body>
<div class="navbar is-white">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item" href="/">
                Habla computing Blog
            </a>
            <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>
        <div class="navbar-menu" id="navMenu">
            <div class="navbar-end">
                
                <a class="navbar-item" href="/authors/">Authors</a>
                
            </div>
        </div>
    </div>
</div>

    <section class="hero  is-medium  is-bold is-dark"  style="background: url('/img/default-post.svg') no-repeat center center; background-size: cover;" >
    <div class="hero-body">
        <div class="container">
            <p class="title is-2">Welcome message</p>
            <p class="subtitle is-3"></p>
        </div>
    </div>
</section>

<section class="section">
    <div class="container">
        

<div class="columns is-centered">
    <div class="column is-8-desktop is-10-tablet">
        <div class="content">
            <p><strong>Published: Feb 11, 2013 by Juan Manuel Serrano</strong></p>
            <p>Think of information systems, Web 2.0 apps, games, e-learning, e-commerce, and the rest of e-* applications. Certainly, these application domains differ significantly in several respects, but can we find some commonalities? We do think so: they deal directly with people; they are deeply concerned with their needs for communication, collaboration and coordination; they all can be regarded as <strong>social apps</strong>. If we have a look to their functional requirements, we will invariably find <em>people</em> playing different <em>roles, saying</em> things to one another, <em>seeing</em> what is happening, generating and consuming <em>information,</em> and so forth; moreover, we will also notice how the application must take into account different normative concerns: <em>permissions</em> to do something, <em>commitments</em> endorsed by particular role players, <em>monitoring</em> rules, etc.</p>
<p>How are these applications developed nowadays? Programmers mainly use object- and functional-oriented programming languages, such as Java, C#, Scala, Haskell, etc. Yet, <em>functions</em> and <em>objects</em> are quite apart from the kinds of<em> social</em> abstractions we just mentioned above. Similarly, <em>factories, facades, monads,</em> etc., are alien to domain experts and non-IT people. The likely result: a daunting amount of accidental complexity leaked into the code. Clearly, if we want to strive for <strong>purely functional</strong> code, i.e. software which directly encode the functional requirements of the application, we have to raise the level of abstraction supported by the programming language.</p>
<p><strong><em>Towards social-oriented programming ... </em></strong></p>
<p>In <a href="http://www.hablapps.com">Habla Computing</a> we are building <strong>Speech,</strong> a domain-specific programming language for implementing the domain logic of social apps. Speech offers the programmer computational counterparts of social concepts such as roles, speech acts, interaction contexts, commitments, permissions, and the like, which aim at closing the gap between natural-language functional requirements and executable code. The net result of this higher-level of abstraction is a drastic reduction in lines-of-code, development times and cost, as well as a significant increase in quality. Of course, we are not alone in this quest for functional purity: the current landscape abounds with domain-specific proposals that aim at simplifying the implementation of business processes, vertical social networks, etc.</p>
<p>Two features, however, distinguish Speech from BPMS, social networking engines, and other domain-specific technologies. First, Speech is not confined to niche domains; do your functional requirements deal directly with people? If so, you can profit from Speech, regardless of the kind of social process supported by the application. Second, Speech is a language for programmers; it is neither a modeling language for business analysts, nor a suite of tools that cope with each functional concern separately. Certainly, we aim at bridging the gap between non-IT people and programmers, and we claim Speech designs to be directly understandable by functional experts. But programmers need a self-sufficient, cohesive and expressive language. Thus, besides being a domain-specific technology, Speech has been designed as a programming language which takes into account every functional concern in a modular and cohesive way. Moreover, in order to foster adoption of Speech in the programming language community, we've decided to offer Speech as an <em>embedded DSL</em>, rather than as a stand-alone implementation.</p>
<p><strong><em>... embedded in Scala!</em></strong></p>
<p>There are several very good languages which enable an embedded implementation strategy, but we finally chose <strong>Scala</strong>. We especially like its mix of functional and object-oriented features, and love its new experimental ones: macros turned out essential for us. This blog will allow us to unveil the major challenges we faced in implementing Speech, and how Scala helped us to solve them. We strive for functional-programming purity in our codebase, so the title of this blog also appeals to that leitmotiv. In this regard, topics that will eventually arise include: coping with updates of immutable objects within generic contexts; dealing with references to evolving immutable objects; etc. Some of these issues lead us to develop general-purpose libraries that we've planned to open-source. We are open to suggestions and recommendations for improvements, and any other form of collaboration. Your feedback is really important to us.</p>
<p>We will also use this blog to announce the release of our products. We are working against the clock to launch the beta release of the Speech interpreter in the following weeks. So, we expect to contact you again very soon. Finally, this blog will also give us the opportunity to advertise our participation in different events. One of these events will take place on 10th-13th April at Cambridge, UK: join us at <a href="http://www.codegeneration.net" target="_blank">Code Generation 2013</a>!</p>

        </div>

        <div class="tags">
            
        </div>

        
        
    </div>
</div>


    </div>
</section>
<section class="section">
    <div class="container">
        <div class="has-text-centered">
            <p>Theme built by <a href="https://www.csrhymes.com">C.S. Rhymes</a></p>
        </div>
    </div>
</section>
<script src="/assets/js/app.js" type="text/javascript"></script>
</body>
</html>

