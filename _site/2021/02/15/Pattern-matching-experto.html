<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II. - Habla computing Blog</title>
    <link rel="stylesheet" href="/assets/css/app.css">
    <link rel="shortcut icon" type="image/png" href="/favicon.png" />
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II. | Habla computing Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II." />
<meta name="author" content="Alfonso Roa" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Repositorio Si prefieres leer este post en formato notebook, lo tienes disponible en github." />
<meta property="og:description" content="Repositorio Si prefieres leer este post en formato notebook, lo tienes disponible en github." />
<link rel="canonical" href="http://localhost:4000/2021/02/15/Pattern-matching-experto.html" />
<meta property="og:url" content="http://localhost:4000/2021/02/15/Pattern-matching-experto.html" />
<meta property="og:site_name" content="Habla computing Blog" />
<meta property="og:image" content="http://localhost:4000/img/pattern.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-15T00:00:00+01:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="http://localhost:4000/img/pattern.jpg" />
<meta property="twitter:title" content="Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II." />
<script type="application/ld+json">
{"@type":"BlogPosting","image":"http://localhost:4000/img/pattern.jpg","headline":"Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II.","dateModified":"2021-02-15T00:00:00+01:00","datePublished":"2021-02-15T00:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021/02/15/Pattern-matching-experto.html"},"author":{"@type":"Person","name":"Alfonso Roa"},"description":"Repositorio Si prefieres leer este post en formato notebook, lo tienes disponible en github.","url":"http://localhost:4000/2021/02/15/Pattern-matching-experto.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-140060849-1"></script>
<script>
  window['ga-disable-UA-140060849-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-140060849-1');
</script></head>

<body>
<div class="navbar is-white">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item" href="/">
                Habla computing Blog
            </a>
            <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navMenu">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>
        <div class="navbar-menu" id="navMenu">
            <div class="navbar-end">
                
                <a class="navbar-item" href="/authors/">Authors</a>
                
            </div>
        </div>
    </div>
</div>

    <section class="hero  is-medium  is-bold is-dark"  style="background: url('/img/pattern.jpg') no-repeat center center; background-size: cover;" >
    <div class="hero-body">
        <div class="container">
            <p class="title is-2">Todo lo que quieres saber y nunca te atreviste a preguntar del pattern matching. Parte II.</p>
            <p class="subtitle is-3"></p>
        </div>
    </div>
</section>

<section class="section">
    <div class="container">
        
<div class="intro">
    <div class="columns is-centered">
        
        <div class="column is-4-desktop is-6-tablet">
            <p class="title is-1">Pattern matching de la K a la Z</p>
        </div>
    </div>
</div>


<div class="columns is-centered">
    <div class="column is-8-desktop is-10-tablet">
        <div class="content">
            <p><strong>Published: Feb 15, 2021 by Alfonso Roa</strong></p>
            <h2 id="repositorio">Repositorio</h2>
<p>Si prefieres leer este post en formato notebook, lo tienes disponible en <a href="https://github.com/alfonsorr/pattern-matching-post">github</a>.</p>

<p>Si quieres comentar este post, hacer alguna pregunta o sugerencia, puedes usar nuestro <a href="https://github.com/hablapps/blog/discussions/4">foro del post</a></p>

<h2 id="conocimientos-avanzados-de-pattern-matching">Conocimientos avanzados de pattern matching</h2>
<p>En el anterior post ya vimos todas las posibilidades que nos ofrece el pattern matching para realizar nuestras condiciones. Ahora verás como puedes llevar esta herramienta a un nivel superior</p>

<h2 id="bricomanía-crea-tus-propios-extractores">Bricomanía: crea tus propios extractores</h2>
<p>Ya vimos que los extractores nos permiten descomponer el elemento que pasamos al <code class="language-plaintext highlighter-rouge">match</code> sacando información interna.</p>

<p>¿Y cómo puede ser esto posible? ¿Cuándo se que algo se puede descomponer o no? Muy sencillo, tenemos que ver si existe en una clase u objeto un método llamado <code class="language-plaintext highlighter-rouge">unapply</code>. Este es el truco que usa scala para poder descomponer algo. Scala tiene ya preparado este método en el objeto de compañía para todos sus tipos básicos (tuplas, listas o toda case class que creas).</p>

<h3 id="extractores-básicos">Extractores básicos</h3>

<p>Lo primero a tener en cuenta son los elementos que entran en el método, en este caso siempre tiene que ser uno y del tipo que queremos descomponer, y lo que devolverá siempre ha de ser un Option, que será del tipo extraido.</p>

<p>Veamos un ejemplo primero, en el que queremos comprobar si un string se puede transformar a un integer. El problema es que el método <code class="language-plaintext highlighter-rouge">toInteger</code> que scala nos provee lanza excepciones, por lo que no es seguro usarlo desde un pattern matching. Sin embargo, nosotros podemos crear una clase que lo permita.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">ValidIntString</span> <span class="o">{</span> <span class="c1">// creamos el objeto que permitirá extraer el string si es valido</span>
    <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="c1">// esperamos descomponer un string, y poder sacar un integer si es posible</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Some</span><span class="o">(</span><span class="nv">string</span><span class="o">.</span><span class="py">toInt</span><span class="o">)</span> <span class="c1">// Si logra ejecutar sin excepciones, devolverá un some con el valor</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">None</span> <span class="c1">// en caso que no fuera integer, lanzaría excepción, por lo que devolvemos None</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">object</span> <span style="color:cyan">ValidIntString</span></p>

<p>Ahora podemos usar nuestro flamante nuevo extractor</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"123"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ValidIntString</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es un integer con valor $n"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es integer"</span>
<span class="o">}</span>

<span class="s">"hola"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ValidIntString</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es un integer con valor $n"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es integer"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">res36_0</span>: <span style="color:green">String</span> = <span style="color:green">“es un integer con valor 123”</span><br />
<span style="color:cyan">res36_1</span>: <span style="color:green">String</span> = <span style="color:green">“no es integer”</span></p>

<p>Funciona perfectamente, pero ¿y si quisiera devolver más de un elemento, como por ejemplo hacen en la tupla que vimos antes? Simplemente tenemos que devolver una tupla. Por ejemplo si el valor se puede transformar en integer queremos devolver una tupla que contenga ese valor y su doble.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">ValidIntStringWithDouble</span> <span class="o">{</span> <span class="c1">// creamos el objeto que permitirá extraer el string si es valido</span>
    <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// esperamos descomponer un string, y poder sacar una tupla de integes si es posible</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nv">string</span><span class="o">.</span><span class="py">toInt</span>
        <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// Si logra ejecutar sin excepciones, devolverá un Some con el valor</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">None</span> <span class="c1">// en caso que no fuera integer, lanzaría excepción, por lo que devolvemos None</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">object</span> <span style="color:cyan">ValidIntStringWithDouble</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"123"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ValidIntStringWithDouble</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es un integer con valor $n y su doble $n2"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es integer"</span>
<span class="o">}</span>

<span class="s">"hola"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ValidIntStringWithDouble</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es un integer con valor $n y su doble $n2"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es integer"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">res38_0</span>: <span style="color:green">String</span> = <span style="color:green">“es un integer con valor 123 y su doble 246”</span><br />
<span style="color:cyan">res38_1</span>: <span style="color:green">String</span> = <span style="color:green">“no es integer”</span></p>

<h5 id="extractores-variádico">Extractores variádico</h5>

<p>Si necesitamos un número indeterminado de elementos a devolver podemos hacer uso de la variante variádico unapplySeq, en la que devolveremos una secuencia de elementos. Cuando se hace la extracción en el match, se tiene en cuenta el número de elementos que se le pasan como argumento.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">SplitDecimals</span> <span class="o">{</span> <span class="c1">// creamos el objeto que permitirá extraer el string si es valido</span>
    <span class="k">def</span> <span class="nf">unapplySeq</span><span class="o">(</span><span class="n">string</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="c1">// esperamos descomponer un string, y devolver un número indefinido de parámetros.</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">x</span> <span class="k">=</span> <span class="nv">string</span><span class="o">.</span><span class="py">toFloat</span>
        <span class="k">val</span> <span class="nv">hasDecimals</span> <span class="k">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="c1">// si es par tendrá 2 elementos la lista, si es impar solo uno</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">hasDecimals</span><span class="o">)</span>
          <span class="nc">Some</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="n">x</span> <span class="o">/</span> <span class="mi">1</span><span class="o">).</span><span class="py">toInt</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">1000000</span><span class="o">).</span><span class="py">toInt</span><span class="o">))</span> <span class="c1">// Al ser par devolvemos 2 elementos</span>
        <span class="k">else</span>
          <span class="nc">Some</span><span class="o">(</span><span class="nc">List</span><span class="o">((</span><span class="n">x</span> <span class="o">/</span> <span class="mi">1</span><span class="o">).</span><span class="py">toInt</span><span class="o">))</span> <span class="c1">// Al ser impar devolvemos solo uno</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">None</span> <span class="c1">// en caso que no fuera integer, lanzaría excepción, por lo que devolvemos None</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">object</span> <span style="color:cyan">SplitDecimals</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"123.0000"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene decimales: $n1 . $n2"</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es entero y tenemos $n1 solo"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es numerico"</span>
<span class="o">}</span>

<span class="s">"123.56454"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene decimales: $n1 . $n2"</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es entero y tenemos $n1 solo"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es numerico"</span>
<span class="o">}</span>

<span class="s">"hola"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene decimales: $n1 y $n2"</span>
    <span class="k">case</span> <span class="nc">SplitDecimals</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es entero y tenemos $n1 solo"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es numerico"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">res40_0</span>: <span style="color:green">String</span> = <span style="color:green">“es entero y tenemos 123 solo”</span><br />
<span style="color:cyan">res40_1</span>: <span style="color:green">String</span> = <span style="color:green">“tiene decimales: 123 . 564537”</span><br />
<span style="color:cyan">res40_2</span>: <span style="color:green">String</span> = <span style="color:green">“no es numerico”</span></p>

<h4 id="extractores-booleanos">Extractores Booleanos</h4>

<p>Por último, scala permite otro tipo de extractor en el que no interesa extraer un elemento si no ver si cumple una propiedad. Al igual que hacemos en la parte de refinado, en la que podemos comprobar si cumple una condición declarándolo explicitamente. Tambien podríamos encapsular esa lógica para darle un nombre legible. Para hacer esto también tenemos que crear un extractor con el método unapply, pero en vez de devolver un <code class="language-plaintext highlighter-rouge">Option</code>, solo tenemos que devolver un <code class="language-plaintext highlighter-rouge">Boolean</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">IsEaven</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">int</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">object</span> <span style="color:cyan">IsEaven</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">54</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">IsEaven</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"el valor es par"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"el valor es impar"</span>
<span class="o">}</span>

<span class="mi">45</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">IsEaven</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"el valor es par"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"el valor es impar"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">res42_0</span>: <span style="color:green">String</span> = <span style="color:green">“el valor es par”</span><br />
<span style="color:cyan">res42_1</span>: <span style="color:green">String</span> = <span style="color:green">“el valor es impar”</span></p>

<p>Y aunque en ejemplos anteriores siempre usamos <code class="language-plaintext highlighter-rouge">object</code>para crear nuestro extractor, también podemos hacer un extractor que requiera parámetros usando <code class="language-plaintext highlighter-rouge">class</code>. Por requermientos de la sintaxis tenemos que instanciarlo antes, para no confundir los parámetros del extractor con las comparaciones que queremos hacer.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">GreaterThan</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">unapply</span><span class="o">(</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">int</span> <span class="o">&gt;</span> <span class="n">c</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">class</span> <span style="color:cyan">GreaterThan</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">mayor45</span> <span class="k">=</span> <span class="nc">GreaterThan</span><span class="o">(</span><span class="mi">45</span><span class="o">)</span>

<span class="mi">54</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">mayor45</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"el valor es mayor que 45"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"el valor es menor o igual"</span>
<span class="o">}</span>

<span class="mi">23</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">mayor45</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"el valor es mayor que 45"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"el valor es menor o igual"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">mayor45</span>: <span style="color:green">GreaterThan</span> = <span style="color:yellow">GreaterThan</span>(<span style="color:green">45</span>)
<span style="color:cyan">res44_1</span>: <span style="color:green">String</span> = <span style="color:green">“el valor es mayor que 45”</span><br />
<span style="color:cyan">res44_2</span>: <span style="color:green">String</span> = <span style="color:green">“el valor es menor o igual”</span></p>

<h4 id="usos-de-extractores-ya-implementados-en-scala">Usos de extractores ya implementados en scala</h4>

<p>Con estos ejemplos podemos ver que los extractores no solo sirven para facilitarnos acceder a los elementos, si no que también nos permiten hacer validaciones. Por ejemplo, en scala se usa para permitir el uso de regex en pattern matching y poder extraer los elementos (o grupos) que capturamos.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fecha</span> <span class="k">=</span> <span class="n">raw</span><span class="s">"(\d{4})-(\d{2})-(\d{2})"</span><span class="o">.</span><span class="py">r</span>

<span class="s">"2004-01-20"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">year</span><span class="o">,</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"año: $year, mes: $month, dia: $day"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es una fecha"</span>
<span class="o">}</span>

<span class="s">"hola"</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">year</span><span class="o">,</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"año: $year, mes: $month, dia: $day"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es una fecha"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">fecha</span>: <span style="color:green">scala</span>.<span style="color:green">util</span>.<span style="color:green">matching</span>.<span style="color:green">Regex</span> = (\d{4})-(\d{2})-(\d{2})
<span style="color:cyan">res45_1</span>: <span style="color:green">String</span> = <span style="color:green">“a\u00f1o: 2004, mes: 01, dia: 20”</span><br />
<span style="color:cyan">res45_2</span>: <span style="color:green">String</span> = <span style="color:green">“no es una fecha”</span></p>

<p>Otro caso es poder matchear las listas, esperando un número específico de elementos</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene solo un elemento $n1"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene dos elementos $n1, $n2"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene tres elementos $n1, $n2, $n3"</span>
    <span class="k">case</span> <span class="n">l</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene demasiados elementos, exactamente  ${l.size}"</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene solo un elemento $n1"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene dos elementos $n1, $n2"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene tres elementos $n1, $n2, $n3"</span>
    <span class="k">case</span> <span class="n">l</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene demasiados elementos, exactamente  ${l.size}"</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene solo un elemento $n1"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene dos elementos $n1, $n2"</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">,</span> <span class="n">n3</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene tres elementos $n1, $n2, $n3"</span>
    <span class="k">case</span> <span class="n">l</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tiene demasiados elementos, exactamente  ${l.size}"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">res46_0</span>: <span style="color:green">String</span> = <span style="color:green">“tiene tres elementos 1, 2, 3”</span><br />
<span style="color:cyan">res46_1</span>: <span style="color:green">String</span> = <span style="color:green">“tiene solo un elemento 1”</span><br />
<span style="color:cyan">res46_2</span>: <span style="color:green">String</span> = <span style="color:green">“tiene demasiados elementos, exactamente  4”</span></p>

<h3 id="obtener-el-elemento-original-y-poder-aplicar-un-patrón">Obtener el elemento original y poder aplicar un patrón.</h3>

<p>El uso de extractores es muy común, pero podemos llegar al caso en el que nos interesaría poder tener el valor original en la condición además de una extracción. Para esto podemos hacer uso del símbolo <code class="language-plaintext highlighter-rouge">@</code>, con el que podemos asignar el valor original a un valor y a continuación del símbolo descomponerlo con un patrón.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fecha</span> <span class="k">=</span> <span class="n">raw</span><span class="s">"(\d{4})-(\d{2})-(\d{2})"</span><span class="o">.</span><span class="py">r</span>

<span class="s">"2004-01-20"</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">d</span> <span class="k">@</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">year</span><span class="o">,</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"año: $year, mes: $month, dia: $day original $d"</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es una fecha"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">fecha</span>: <span style="color:green">scala</span>.<span style="color:green">util</span>.<span style="color:green">matching</span>.<span style="color:green">Regex</span> = (\d{4})-(\d{2})-(\d{2})<br />
<span style="color:cyan">res47_1</span>: <span style="color:green">String</span> = <span style="color:green">“a\u00f1o: 2004, mes: 01, dia: 20 original 2004-01-20”</span></p>

<h2 id="ahora-todo-a-la-vez">¡Ahora todo a la vez!</h2>

<p>Haciendo uso de todo lo visto hasta ahora y a modo de recordatorio, se pueden realizar comparativas complejas en muy poco código:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fecha</span> <span class="k">=</span> <span class="n">raw</span><span class="s">"(\d{4})-(\d{2})-(\d{2})"</span><span class="o">.</span><span class="py">r</span> <span class="c1">// regex para fechas con guion 2020-01-01</span>

<span class="k">val</span> <span class="nv">anio19xx</span> <span class="k">=</span> <span class="n">raw</span><span class="s">"19(\d{2})"</span><span class="o">.</span><span class="py">r</span> <span class="c1">// regex para números de 4 cifras que comienzan por 19xx y extrae el xx</span>

<span class="k">val</span> <span class="nv">anioEspecial</span> <span class="k">=</span> <span class="s">"2001"</span>

<span class="k">def</span> <span class="nf">queDiaEs</span><span class="o">(</span><span class="n">dateStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
<span class="n">dateStr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="c1">// comparación con un valor tras la extracción</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">`anioEspecial`</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"mi año especial :D"</span>
    <span class="c1">// comparación con literal tras extracción</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="s">"01"</span><span class="o">,</span> <span class="s">"01"</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"feliz año nuevo!"</span>
    <span class="c1">// asignación del valor original y comparación en la extracción</span>
    <span class="k">case</span> <span class="n">d</span> <span class="k">@</span> <span class="nf">fecha</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="s">"02"</span><span class="o">,</span> <span class="s">"29"</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"es año bisiesto $d"</span>
    <span class="c1">// varios posibles casos de un elemento extraido</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="s">"1800"</span> <span class="o">|</span> <span class="s">"1700"</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"eso es muy viejo"</span>
    <span class="c1">// refinamiento tras extracción</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">year</span><span class="o">,</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">if</span> <span class="nv">year</span><span class="o">.</span><span class="py">reverse</span> <span class="o">==</span> <span class="o">(</span><span class="n">month</span> <span class="o">+</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"la fecha es capicua $year$month$day"</span>
    <span class="c1">// extracción de un elemento obtenido por una extracción</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="nf">anio19xx</span><span class="o">(</span><span class="n">year19</span><span class="o">),</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$day del $month del año $year19"</span>
    <span class="k">case</span> <span class="nf">fecha</span><span class="o">(</span><span class="n">year</span><span class="o">,</span> <span class="n">month</span><span class="o">,</span> <span class="n">day</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"año: $year, mes: $month, dia: $day"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no es una fecha"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">fecha</span>: <span style="color:green">scala</span>.<span style="color:green">util</span>.<span style="color:green">matching</span>.<span style="color:green">Regex</span> = (\d{4})-(\d{2})-(\d{2})
<span style="color:cyan">anio19xx</span>: <span style="color:green">scala</span>.<span style="color:green">util</span>.<span style="color:green">matching</span>.<span style="color:green">Regex</span> = 19(\d{2})
<span style="color:cyan">anioEspecial</span>: <span style="color:green">String</span> = <span style="color:green">“2001”</span><br />
defined <span style="color:green">function</span> <span style="color:cyan">queDiaEs</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2001-03-01"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2021-01-01"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2020-02-29"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"1800-03-29"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"1700-03-29"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2020-02-02"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"1995-02-03"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2021-31-10"</span><span class="o">)</span>
<span class="nf">queDiaEs</span><span class="o">(</span><span class="s">"2021"</span><span class="o">)</span>
</code></pre></div></div>

<p><span style="color:cyan">res49_0</span>: <span style="color:green">String</span> = <span style="color:green">“mi a\u00f1o especial :D”</span><br />
<span style="color:cyan">res49_1</span>: <span style="color:green">String</span> = <span style="color:green">“feliz a\u00f1o nuevo!”</span><br />
<span style="color:cyan">res49_2</span>: <span style="color:green">String</span> = <span style="color:green">“es a\u00f1o bisiesto 2020-02-29”</span><br />
<span style="color:cyan">res49_3</span>: <span style="color:green">String</span> = <span style="color:green">“eso es muy viejo”</span><br />
<span style="color:cyan">res49_4</span>: <span style="color:green">String</span> = <span style="color:green">“eso es muy viejo”</span><br />
<span style="color:cyan">res49_5</span>: <span style="color:green">String</span> = <span style="color:green">“la fecha es capicua 20200202”</span><br />
<span style="color:cyan">res49_6</span>: <span style="color:green">String</span> = <span style="color:green">“03 del 02 del a\u00f1o 95”</span><br />
<span style="color:cyan">res49_7</span>: <span style="color:green">String</span> = <span style="color:green">“a\u00f1o: 2021, mes: 31, dia: 10”</span><br />
<span style="color:cyan">res49_8</span>: <span style="color:green">String</span> = <span style="color:green">“no es una fecha”</span></p>

<h3 id="un-error-que-todos-cometemos">Un error que todos cometemos</h3>

<p>Vimos al comienzo que el compilador nos daba un mensaje de advertencia cuando teníamos casos que no eran alcanzables, pero planteo otra duda. ¿Qué ocurre si tenemos un caso que no está contemplado?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tengoDato</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
<span class="n">o</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tenemos el valor 0"</span> <span class="c1">// solo contemplamos Some con el valor 0</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">"no tenemos valor"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:red">Compilador</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd50.sc:2: match may not be exhaustive.  
It would fail on the following input: Some((x: Int forSome x not in 0))  
o match {  
^
</code></pre></div></div>

<p>defined <span style="color:green">function</span> <span style="color:cyan">tengoDato</span></p>

<p>Ya vemos en este caso que solo con la definición ya nos advierte el compilador de que algo falta. Pero si aun así hacemos caso omiso, al ejecutar:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">tengoDato</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala.MatchError: Some(1) (of class scala.Some)  
    ammonite.$sess.cmd50$Helper.tengoDato(cmd50.sc:2)  
    ammonite.$sess.cmd51$Helper.&lt;init&gt;(cmd51.sc:1)  
    ammonite.$sess.cmd51$.&lt;init&gt;(cmd51.sc:7)  
    ammonite.$sess.cmd51$.&lt;clinit&gt;(cmd51.sc:-1)  
</code></pre></div></div>

<p>Obtenemos un error en la ejecución de tipo <code class="language-plaintext highlighter-rouge">scala.MatchError</code>. Y ya hemos dicho que esto en scala hay que evitarlo siempre que sea posible.</p>

<p>Como bien sabrás, scala está muy orientado a que se programe según el paradigma funcional, lo que nos lleva a las funciones puras. Si no conocías el concepto de función pura, podemos resumirlo como que a todo elemento que entra en una función, tiene que devolver un valor. Pero una excepción no es un valor.</p>

<p>Hay que tener en cuenta que esta comprobación de exhausividad solo funciona si trabajamos con ADT’s. Si realizamos este match en un tipo primitivo como son <code class="language-plaintext highlighter-rouge">String</code> o <code class="language-plaintext highlighter-rouge">Int</code>, el compilador no va a poder darnos estas advertencias.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">noExhaustivo</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
<span class="n">o</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tenemos el valor 0"</span>
    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"tenemos el valor 1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>defined <span style="color:green">function</span> <span style="color:cyan">noExhaustivo</span></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">noExhaustivo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="nf">noExhaustivo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="nf">noExhaustivo</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala.MatchError: 2 (of class java.lang.Integer)  
    ammonite.$sess.cmd52$Helper.noExhaustivo(cmd52.sc:2)  
    ammonite.$sess.cmd53$Helper.&lt;init&gt;(cmd53.sc:3)  
    ammonite.$sess.cmd53$.&lt;init&gt;(cmd53.sc:7)  
    ammonite.$sess.cmd53$.&lt;clinit&gt;(cmd53.sc:-1)  
</code></pre></div></div>

<p>Por este motivo siempre es recomendable poner un caso por defecto (<code class="language-plaintext highlighter-rouge">case _ =&gt; </code>) que lo evite si estamos haciendo match sobre un elemento primitivo o clases que no sean ADTs.</p>

<h3 id="un-truco-si-eres-nuevo-o-no-te-fias-ni-de-ti-mismo">Un truco si eres nuevo (o no te fias ni de ti mismo)</h3>

<p>El compilador de scala sabe que un pattern matching es un posible foco de excepciones, por lo que en muchos casos, si ve que no se contemplan todos los casos de entrada, o lo que es lo mismo, no es exhaustivo, nos dará un advertencia a nivel de warning.</p>

<p>Yo te doy un consejo, es buena practica hacer que una build falle si hay algún mensaje. Solo tienes que añadir la siguiente opción en tu proyecto sbt:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scalacOptions</span> <span class="o">+=</span> <span class="s">"-Xfatal-warnings"</span>
</code></pre></div></div>

<p>o si eres de los que trabaja con maven, en el plugin de scala añade junto a tus opciones:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;executions&gt;</span>
  <span class="nt">&lt;execution&gt;</span>
    <span class="nt">&lt;configuration&gt;</span>
      <span class="nt">&lt;args&gt;</span>  
        <span class="nt">&lt;arg&gt;</span>-Xfatal-warnings<span class="nt">&lt;/arg&gt;</span>
      <span class="nt">&lt;/args&gt;</span>
    <span class="nt">&lt;/configuration&gt;</span>
  <span class="nt">&lt;/execution&gt;</span>
<span class="nt">&lt;/executions&gt;</span>
</code></pre></div></div>

<p>Con esto ya tenemos todas las herramientas necesarias para convertirnos en un ninja del patter matching. Podemos hacer una gran y compleja lógica de una manera muy legible y mantenible y teniendo al compilador supervisor.</p>

<h2 id="funciones-parciales">Funciones parciales</h2>

<p>Siempre que se ha hablado de pattern matching hemos hecho mucho hincapié en que ha de ser una función pura, es decir, contemplar todos los casos de entrada y que den respuesta a cada uno de ellos. Sin embargo algunas veces fuera del <code class="language-plaintext highlighter-rouge">match</code> solo queremos contemplar una parte de los casos. Esto en scala se llaman funciones parciales y tienen un <a href="https://www.scala-lang.org/api/current/scala/PartialFunction.html">interfaz</a> ya creado para este propósito y que sigue la siguiente estructura:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">-A</span>, <span class="kt">+B</span><span class="o">]{</span>
    <span class="k">def</span> <span class="nf">isDefinedAt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>
</code></pre></div></div>

<p>El método <code class="language-plaintext highlighter-rouge">apply</code> es un método que no es necesario llamar de forma explícita, si no que se llama directamente solo pasándole los parámetros. En este caso sería el equivalente a la parte derecha tras la flecha (<code class="language-plaintext highlighter-rouge">=&gt;</code>) del pattern matching y, como podrás imaginar, <code class="language-plaintext highlighter-rouge">isDefinedAt</code> es el método que representa la condición. Si está definido para el valor a comprobar devuelve verdadero y ejecutaríamos el método apply.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">isEven</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]{</span>
    <span class="k">def</span> <span class="nf">isDefinedAt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">v1</span><span class="o">+</span><span class="s">" is even"</span>
<span class="o">}</span>

</code></pre></div></div>

<p><span style="color:cyan">isEven</span>: <span style="color:green">PartialFunction</span>[<span style="color:green">Int</span>, <span style="color:green">String</span>] = <function1></function1></p>

<p>Esto no quiere decir que nosotros tengamos que crear una instancia de <code class="language-plaintext highlighter-rouge">PartialFunction</code> de forma explícita, porque para eso tenemos la sintaxis que usabamos anteriormente.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">isEven</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="s">" is even"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">isEven</span>: <span style="color:green">PartialFunction</span>[<span style="color:green">Int</span>, <span style="color:green">String</span>] = <function1></function1></p>

<p>Con esto, vemos uno de los grandes secretos del pattern matching. En el fondo solo es azúcar sintáctico que el compilador traduce al interfaz <code class="language-plaintext highlighter-rouge">PartialFunction</code>.</p>

<p>¿Y qué usos podemos hacer de las funciones parciales? Pues podemos aplicarlas cuando necesitamos saber dos cosas: sobre qué podemos aplicar esta función, y si es el caso, qué queremos hacer con ellas. Por ejemplo el método <code class="language-plaintext highlighter-rouge">collect</code> de las colecciones, con el que seleccionamos solo los que pasan la criba y los transformados como se indica:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">collect</span><span class="o">(</span><span class="n">isEven</span><span class="o">)</span>
</code></pre></div></div>

<p><span style="color:cyan">res56</span>: <span style="color:green">List</span>[<span style="color:green">String</span>] = <span style="color:yellow">List</span>(<span style="color:green">“2 is even”</span>, <span style="color:green">“4 is even”</span>)</p>

<p>Otra de las particularidades de las funciones parciales es que se pueden combinar para contemplar más casos.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">isEven</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">+</span><span class="s">" is even"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">isOdd</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">+</span><span class="s">" is odd"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">pf</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">isEven</span><span class="o">.</span><span class="py">orElse</span><span class="o">(</span><span class="n">isOdd</span><span class="o">)</span>

<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">pf</span><span class="o">)</span>
</code></pre></div></div>

<p><span style="color:cyan">isEven</span>: <span style="color:green">PartialFunction</span>[<span style="color:green">Int</span>, <span style="color:green">String</span>] = <function1>
<span style="color:cyan">isOdd</span>: <span style="color:green">PartialFunction</span>[<span style="color:green">Int</span>, <span style="color:green">String</span>] = <function1>
<span style="color:cyan">pf</span>: <span style="color:green">PartialFunction</span>[<span style="color:green">Int</span>, <span style="color:green">String</span>] = <function1>
<span style="color:cyan">res57_3</span>: <span style="color:green">List</span>[<span style="color:green">String</span>] = <span style="color:yellow">List</span>(<span style="color:green">"1 is odd"</span>, <span style="color:green">"2 is even"</span>, <span style="color:green">"3 is odd"</span>, <span style="color:green">"4 is even"</span>)</function1></function1></function1></p>

<p>En este caso, somos nosotros los que tenemos que asegurar que es exhaustivo.</p>

<h2 id="aplicación-de-pattern-matching-en-lambdas">Aplicación de pattern matching en lambdas</h2>

<p>Muchas veces cuando queremos hacer un pattern matching es creando una lambda, por ejemplo en un método map.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optval</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="nv">optval</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">"es 1"</span>
    <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">"es el número 2"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"es otro número"</span>
<span class="o">})</span>


</code></pre></div></div>

<p><span style="color:cyan">optval</span>: <span style="color:green">Some</span>[<span style="color:green">Int</span>] = <span style="color:yellow">Some</span>(<span style="color:green">4</span>)
<span style="color:cyan">res58_1</span>: <span style="color:green">Option</span>[<span style="color:green">String</span>] = <span style="color:yellow">Some</span>(<span style="color:green">“es otro n\u00famero”</span>)</p>

<p>Como hemos visto en el ejemplo anterior, si la lógica que queremos en esa lambda solo se compone de un pattern matching, podemos simplificar el código. Scala permite realizar un pattern matching con los parámetros pasados a la lambda cambiando el inicio <code class="language-plaintext highlighter-rouge">x =&gt; x match {</code> por las llaves que tienen los casos directamente:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">optval</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="nv">optval</span><span class="o">.</span><span class="py">map</span><span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">"es 1"</span>
    <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">"es el número 2"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"es otro número"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><span style="color:cyan">optval</span>: <span style="color:green">Some</span>[<span style="color:green">Int</span>] = <span style="color:yellow">Some</span>(<span style="color:green">4</span>)
<span style="color:cyan">res59_1</span>: <span style="color:green">Option</span>[<span style="color:green">String</span>] = <span style="color:yellow">Some</span>(<span style="color:green">“es otro n\u00famero”</span>)</p>

<p>Y tranquilo, si lo que esperas ha de ser una función completa o pura, ya te avisará el compilador si es exhaustivo o no (en los casos que vimos previamente).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">foo</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>

<span class="nv">foo</span><span class="o">.</span><span class="py">map</span><span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">5</span>
<span class="o">}</span>

<span class="c1">// tenemos advertencia de compilación y además error en la ejecución</span>
</code></pre></div></div>

<p><span style="color:red">Compilador</span></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd60.sc:3: match may not be exhaustive.
It would fail on the following input: None
val res60_1 = foo.map{
                     ^
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    scala.MatchError: None (of class scala.None$)  
      ammonite.$sess.cmd60$Helper.$anonfun$res60_1$1(cmd60.sc:3)  
      ammonite.$sess.cmd60$Helper.$anonfun$res60_1$1$adapted(cmd60.sc:3)  
      scala.collection.immutable.List.map(List.scala:297)  
      ammonite.$sess.cmd60$Helper.&lt;init&gt;(cmd60.sc:3)  
      ammonite.$sess.cmd60$.&lt;init&gt;(cmd60.sc:7)  
      ammonite.$sess.cmd60$.&lt;clinit&gt;(cmd60.sc:-1)  
</code></pre></div></div>

<p>Y si ve que espera una función parcial, ahí eres tú el responsable de que esté bien creado. El compilador no puede hacer todo por tí.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">foo</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>

<span class="nv">foo</span><span class="o">.</span><span class="py">collect</span><span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">5</span>
<span class="o">}</span>

<span class="c1">// al ser parcial, no tiene responsabilidad el compilador</span>
</code></pre></div></div>

<p><span style="color:cyan">foo</span>: <span style="color:green">List</span>[<span style="color:green">Option</span>[<span style="color:green">Int</span>]] = <span style="color:yellow">List</span>(<span style="color:yellow">Some</span>(<span style="color:green">4</span>), <span style="color:green">None</span>, <span style="color:yellow">Some</span>(<span style="color:green">1</span>))
<span style="color:cyan">res61_1</span>: <span style="color:green">List</span>[<span style="color:green">Int</span>] = <span style="color:yellow">List</span>(<span style="color:green">5</span>, <span style="color:green">5</span>)</p>

<h2 id="scala-3">Scala 3</h2>

<p>Ahora toca mirar al futuro próximo. En pocos meses tras la fecha de este post saldrá una nueva versión de scala denominada dotty o scala 3. En esta se ha reescrito el compilador y van a tener muchas novedades. Respecto al pattern matching, no va a haber grandes cambios. Todo lo que se ha visto para indicar la condición se mantiene tal cual. Pero sí merece la pena destacar unos puntos y ya de paso los escribimos con la sintaxis nueva que nos permite scala 3, omitiendo llaves y cambiandolas por <code class="language-plaintext highlighter-rouge">:</code>.</p>

<h3 id="match-como-función">Match como ‘función’</h3>
<p>Un pequeño cambio respecto a la palabra <code class="language-plaintext highlighter-rouge">match</code>: sigue siendo una palabra reservada, pero ahora se puede usar como llamada a un método, es decir, usando punto respecto al valor. Eso si, tras <code class="language-plaintext highlighter-rouge">match</code> se pueden eliminar las llaves, sin necesidad de poner <code class="language-plaintext highlighter-rouge">:</code></p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">45.</span><span class="k">match</span>
    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="s">"es 1"</span>
    <span class="k">case</span> <span class="mi">2</span> <span class="k">=&gt;</span> <span class="s">"es el número 2"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"es otro número"</span>

</code></pre></div></div>
<p><a href="https://scastie.scala-lang.org/alfonsorr/qeozSdkzTvOTseiCc0OmnA">link para ejemplo interactivo</a></p>

<p>Esta forma trata de permitirnos cambiar la prioridad para procesar el pattern matching, permitiéndonos integrarlo fácilmente con otros elementos, por ejemplo:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="mf">4.</span><span class="k">match</span>
     <span class="k">case</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="kc">true</span>
     <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="n">then</span>
  <span class="s">"valor 5"</span>
<span class="k">else</span>
  <span class="s">"otro valor"</span>
</code></pre></div></div>
<p><a href="https://scastie.scala-lang.org/alfonsorr/A4nNc65pSTuvrtWvSkFfaA/8">link para ejemplo interactivo</a></p>

<h3 id="extractores-irrefutables">Extractores ‘irrefutables’</h3>

<p>Otra de las mejoras que se tiene en scala 3 es la creación de extractores. Una limitación que tienen actualmente los extractores de scala 2 es la obligación de devolver los elementos extraidos en un Option, excepto para el caso del extractor Booleano, lo que representa que esa extracción puede no ir bien. Esto impide crear extractores que sabemos que siempre irán correctamente, o como lo llaman en la documentación, ‘irrefutables’. Como por ejemplo el siguiente.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">PreviousAndNextNumber</span><span class="k">:</span>
    <span class="kt">def</span> <span class="kt">unapply</span><span class="o">(</span><span class="kt">int:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">((</span><span class="n">int</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">int</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>

<span class="mi">5</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">PreviousAndNextNumber</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"valor valido"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"valor invalido"</span>
</code></pre></div></div>
<p><a href="https://scastie.scala-lang.org/alfonsorr/Z0kg5fykTh6hE6c2g8GGvQ/1">link para ejemplo interactivo</a></p>

<p>Como se ve, en este extractor se devuelve un elemento <code class="language-plaintext highlighter-rouge">Option[Int]</code> pero nunca va a haber posibilidad de que devolvamos <code class="language-plaintext highlighter-rouge">None</code>. Esto en scala 3 se ha mejorado, permitiendo el uso de extractores que no solo devuelvan <code class="language-plaintext highlighter-rouge">Option</code>, sino también <code class="language-plaintext highlighter-rouge">Product</code>. Recordad que a este último pertenecen tuplas y todas las <code class="language-plaintext highlighter-rouge">case class</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">PreviousAndNextNumber</span><span class="k">:</span>
    <span class="kt">def</span> <span class="kt">unapply</span><span class="o">(</span><span class="kt">int:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">int</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">int</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="mi">1</span>

<span class="mi">5</span> <span class="k">match</span>
    <span class="k">case</span> <span class="nc">PreviousAndNextNumber</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"valor valido"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"valor invalido"</span>

<span class="k">val</span> <span class="nv">PreviousAndNextNumber</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span> <span class="k">=</span> <span class="mi">5</span>

</code></pre></div></div>
<p><a href="https://scastie.scala-lang.org/alfonsorr/IYjlD9BWT9S1z6xRipQpIA/9">link para ejemplo interactivo</a></p>

<p>Esto permite el uso de extractores en las asignaciones, cosa que no se suele usar mucho en scala 2 si no sabemos con exactitud si puede lanzar excepciones en caso de no ser válida la condición.</p>

<p>Y como último apunte ya que hablamos de extractores, se permitirá su uso en los <code class="language-plaintext highlighter-rouge">for comprehesion</code>, pero eso es tema para otro post ;)</p>

<h2 id="resumen-final">Resumen final</h2>
<p>Conociendo que hacen los métodos unapply, o las funciones parciales podemos aplicar la herramienta adecuada en cada momento. Siempre con la intención de hacer un código legible y mantenible.
En scala el <code class="language-plaintext highlighter-rouge">pattern matching</code> siempre ha sido una de sus caracteristicas estrella, y ha madurado mucho. Tanto que en nuevas versiones solo tiene algunas mejoras para poder reutilizar algunos de sus elementos en más lugares.</p>

        </div>

        <div class="tags">
            
        </div>

        
        
        <div class="author-media">
    <div class="media">
        <figure class="media-left">
            <a href="/authors/Alfonso.html">
                <p class="image is-64x64">
                    
                    <img src="/img/team/alfonso.jpg" alt="Alfonso Roa" />
                    
                </p>
            </a>
        </figure>
        <div class="media-content">
            <a href="/authors/Alfonso.html">
                <p class="title is-5">Alfonso Roa</p>
            </a>
            <p class="subtitle is-5">Senior software developer</p>
            <div class="content">
                <p></p>
            </div>
        </div>
    </div>
</div>

        
    </div>
</div>


    </div>
</section>
<section class="section">
    <div class="container">
        <div class="has-text-centered">
            <p>Theme built by <a href="https://www.csrhymes.com">C.S. Rhymes</a></p>
        </div>
    </div>
</section>
<script src="/assets/js/app.js" type="text/javascript"></script>
</body>
</html>

