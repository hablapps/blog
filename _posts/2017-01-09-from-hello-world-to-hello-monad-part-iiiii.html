---
layout: post
title: From “Hello, world!” to “Hello, monad!” (Part II/III)
date: 2017-01-09 17:49:35.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Embedded DSLs
- functional programming
- Scala
tags: []
meta:
  _wpcom_is_markdown: '1'
  _thumbnail_id: '65'
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '572276751'
author:
  login: javifdev
  email: javierfs.89@gmail.com
  display_name: javifdev
  first_name: Javier
  last_name: Fuentes
permalink: "/2017/01/09/from-hello-world-to-hello-monad-part-iiiii/"
---
<p>In the <a href="http://blog.hablapps.com/2016/01/22/from-hello-world-to-hello-monad-part-i/">first part</a> of this series, we set forth the essence of functional programming, namely, <em>being declarative</em>. This was illustrated with the ubiquitous "Hello, world!" example, a ridiculously simple program which, nonetheless, allowed us to introduce the major concepts involved in purely functional programming: declarative functions, languages, and interpreters. It's time now to show that this approach actually scales up for larger and more complex programs.</p>
<p>In the following paragraphs, you'll find a series of impure IO programs that represent purification challenges. Compare to the simple "Hello, world!" program, these new programs feature additional IO instructions, and an increasingly complex control flow structure. These extra levels of complexity will force us to enrich the simple <code>IOProgram</code> DSL and interpreter that we created to purify the simple "Hello, world!" program. For easy of reference, we reproduce that initial purification bellow:</p>
<p>[sourcecode language="scala"]<br />
object HelloWorld{<br />
  /* Impure program */<br />
  def helloWorld: String =<br />
    println(&quot;Hello, world!&quot;)</p>
<p>  /* Functional solution */<br />
  object Fun {<br />
    // Language<br />
    type IOProgram = Print<br />
    case class Print(msg: String)</p>
<p>    // Pure function<br />
    def pureHello(): IOProgram =<br />
      Print(&quot;Hello, world!&quot;)</p>
<p>    // Interpreter<br />
    def run(program: IOProgram): Unit =<br />
      program match {<br />
        case Print(msg) =&gt; println(msg)<br />
      }</p>
<p>    // Impure program (modularised)<br />
    def hello() = run(pureHello())<br />
  }<br />
}<br />
[/sourcecode]</p>
<h2>Say what?</h2>
<p>Our first challenge consists in purifying the following impure program:</p>
<p>[sourcecode language="scala"]<br />
def sayWhat: String =<br />
  readLine<br />
[/sourcecode]</p>
<p>Similarly to the "Hello, world!" program, the "sayWhat" program consists of a single IO instruction. In this case, when the program is run it will immediately block until we type something in the console. Then, it will return the string typed, rather than <code>Unit</code>:</p>
<p>[sourcecode language="scala"]<br />
scala&gt; SayWhat.sayWhat<br />
(type &quot;something&quot;)<br />
res0: String = &quot;something&quot;<br />
[/sourcecode]</p>
<p>In order to purify any program we have to return pure values that represent a description of the logic we want to accomplish. In order to describe this logic, we use the IOProgram DSL, but the current version of this DSL does only offer a <code>Write</code> instruction, so we have to extend it with a new <code>Read</code> command:</p>
<p>[sourcecode language="scala"]<br />
type IOProgram[A] = IOEffect[A]</p>
<p>sealed trait IOEffect[A]<br />
case class Write(msg: String) extends IOEffect[Unit]<br />
case object Read extends IOEffect[String]<br />
[/sourcecode]</p>
<p>There are several things going on here:</p>
<ul>
<li>We chose to use an ADT (Algebraic Data Type) to represent our instructions. We created an <em>effect Language</em> to perform IO operations, composed by two instructions, one to read from and the other to write to the console. And our programs consist of either one of these instructions.</li>
<li>The new <code>Read</code> instruction is a <code>case object</code> because it is a singleton instance; there can only exist one and only one instance of <code>Read</code> as it has no arguments.</li>
<li>Another thing to point out is that we parameterized our <code>IOEffect</code> and <code>IOProgram</code> ADTs. We did that because we need to store the return type of our instructions somewhere in order to be able to implement the interpreter. So in this case we use a <em>phantom type</em> to carry that information over. Thus, the <code>IOEffect</code> algebraic data type is what is known as a Generalised Algebraic Data type (GADT).</li>
</ul>
<p>We got it. Now we can express the impure "sayWhat" program in a pure fashion as follows:</p>
<p>[sourcecode language="scala"]<br />
def pureSayWhat: IOProgram[String] = Read<br />
[/sourcecode]</p>
<p>As simple as that. But things become more complicated when we try to update our interpreter:</p>
<p>[sourcecode language="scala"]<br />
def run(program: IOProgram): ??? = ...<br />
[/sourcecode]</p>
<p>Now our programs are parameterized so we need to change the signature a little bit; remember that the return type is stored in the program type parameter. We can use good old pattern matching to know which instruction we are dealing with (Scala's support for pattern matching GADTs suffices in this case):</p>
<p>[sourcecode language="scala"]<br />
def run[A](program: IOProgram[A]): A =<br />
  program match {<br />
    case Write(msg) =&gt; println(msg)<br />
    case Read =&gt; readLine<br />
  }<br />
[/sourcecode]</p>
<p>The only thing left to do is reimplementing in a modular fashion our equivalent impure function. I'll leave the complete example below:</p>
<p>[sourcecode language="scala"]<br />
object SayWhat {<br />
  /* Impure program */<br />
  def sayWhat: String = readLine</p>
<p>  /* Functional solution */<br />
  object Fun {<br />
    // Language<br />
    type IOProgram[A] = IOEffect[A]</p>
<p>    sealed trait IOEffect[A]<br />
    case class Write(msg: String) extends IOEffect[Unit]<br />
    case object Read extends IOEffect[String]</p>
<p>    // Pure Program<br />
    def pureSayWhat: IOProgram[String] = Read</p>
<p>    // Interpreter<br />
    def run[A](program: IOProgram[A]): A =<br />
      program match {<br />
        case Write(msg) =&gt; println(msg)<br />
        case Read =&gt; readLine<br />
      }</p>
<p>    // Composition<br />
    def sayWhat: String = run(pureSayWhat)<br />
  }<br />
}<br />
[/sourcecode]</p>
<h2>Say What? (reloaded)</h2>
<p>We'll start now building programs with more than one instruction. In this case we are going to print something to the console and then read the user's input.</p>
<h3>Impure program</h3>
<p>[sourcecode language="scala"]<br />
def helloSayWhat: String = {<br />
  println(&quot;Hello, say something:&quot;)<br />
  readLine<br />
}<br />
[/sourcecode]</p>
<p>As you can see, this is a common <em>imperative</em> program which can be read out aloud as follows: "first, do this; next, do this".</p>
<h3>Pure function and language</h3>
<p>So far, our program definition has been just a type alias of a single instruction, but now we want our programs to be able to represent two-instructions programs as well. It turns out our program definition must be also an ADT:</p>
<p>[sourcecode language="scala"]<br />
sealed trait IOProgram[A]<br />
case class Single[A](e: IOEffect[A]) extends IOProgram[A]<br />
case class Sequence[A, B](e1: IOProgram[A], e2: IOProgram[B]) extends IOProgram[B]</p>
<p>def pureHelloSayWhat: IOProgram[String] =<br />
  Sequence(<br />
    Single(Write(&quot;Hello, say something:&quot;)),<br />
    Single(Read))<br />
[/sourcecode]</p>
<p>As you can see, our programs can now be made up of just a <code>Single</code> instruction or a <code>Sequence</code> of two programs.</p>
<h3>Interpreter</h3>
<p>We must now change the interpreter accordingly. In particular, we need two interpreters, one for programs and one for effects:</p>
<p>[sourcecode language="scala"]<br />
def run[A](program: IOProgram[A]): A =<br />
  program match {<br />
    case Single(e) =&gt; runEffect(e)<br />
    case Sequence(p1, p2) =&gt;<br />
      runProgram(p1) ; runProgram(p2)<br />
  }</p>
<p>def runEffect[A](effect: IOEffect[A]): A =<br />
  effect match {<br />
    case Write(msg) =&gt; println(msg)<br />
    case Read =&gt; readLine<br />
  }<br />
[/sourcecode]</p>
<h3>Composition</h3>
<p>The only thing left is to rewrite the impure program in a modular fashion:</p>
<p>[sourcecode language="scala"]<br />
def sayWhat: String = run(pureHelloSayWhat)<br />
[/sourcecode]</p>
<h2>Echo, echo!</h2>
<p>In our next program we'll complicate the control flow a little bit.</p>
<h3>Impure program</h3>
<p>[sourcecode language="scala"]<br />
def echo: Unit = {<br />
  val read: String = readLine<br />
  println(read)<br />
}<br />
[/sourcecode]</p>
<p>Note that the <code>println</code> instruction is writing the result of the <code>read</code> operation. This is a behaviour we can't describe with our program representation yet. The problem is that the <code>Sequence</code> case doesn't allow us to use the result of the first program. We thus need somehow to represent context-dependent programs, i.e. programs that depend on the results of previous ones. Let's fix that.</p>
<h3>Pure function and language</h3>
<p>[sourcecode language="scala"]<br />
sealed trait IOProgram[A]<br />
case class Single[A](e: IOEffect[A]) extends IOProgram[A]<br />
case class Sequence[A, B](e1: IOProgram[A],<br />
  e2: A =&gt; IOProgram[B]) extends IOProgram[B]</p>
<p>def pureEcho: IOProgram[Unit] =<br />
  Sequence(<br />
    Single(Read), read =&gt;<br />
    Single(Write(read)) )<br />
[/sourcecode]</p>
<p>As simple as that, the new version of <code>Sequence</code> carries as its second parameter a program that is allowed to depend on a value of type <code>A</code>, i.e. the type of values returned when the first program is interpreted. Of course, the intention is that the interpreter will apply this function to that precise value, as will be shown in the next section. By the way, does the signature of the new version of <code>Sequence</code> ring a bell?</p>
<h3>Interpreter</h3>
<p>As commented previously, the new version of the interpreter will simply need to modify the way in which sequenced programs are executed:</p>
<p>[sourcecode language="scala"]<br />
def runProgram[A](program: IOProgram[A]): A =<br />
  program match {<br />
    case Single(e) =&gt; runEffect(e)<br />
    case Sequence(p, next) =&gt;<br />
      val res = runProgram(p)<br />
      runProgram(next(res))<br />
  }<br />
[/sourcecode]</p>
<h3>Composition</h3>
<p>The last thing to do is to reimplement the impure function in a modular way by applying the interpreter to the result of the pure function.</p>
<p>[sourcecode language="scala"]<br />
def echo: Unit = runProgram(pureEcho)<br />
[/sourcecode]</p>
<h2>On pure values</h2>
<p>There are still some impure IO programs we can't represent with our current <code>IOProgram</code> ADT. In particular, think of imperative programs structured as follows: <em>"Do this program; then, do this other program, possible taking into account the result of the last program; etc.; finally, return this value, possible taking into account the results of the last steps."</em>. It's the last step which can't be represented. For instance, let's consider the following program.</p>
<h3>Impure program</h3>
<p>[sourcecode language="scala"]<br />
def echo(): String = {<br />
  val read: String = readLine<br />
  println(read)<br />
  read<br />
}<br />
[/sourcecode]</p>
<p>This program is similar to the last one, but this time we return the <em>String</em> read, i.e., a pure value. So let's add this new functionality to our ADT.</p>
<h3>Pure function and language</h3>
<p>[sourcecode language="scala"]<br />
sealed trait IOProgram[A]<br />
case class Single[A](e: IOEffect[A]) extends IOProgram[A]<br />
case class Sequence[A, B](e1: IOProgram[A],<br />
  e2: A =&gt; IOProgram[B]) extends IOProgram[B]<br />
case class Value[A](a: A) extends IOProgram[A]</p>
<p>def pureEcho: IOProgram[String] =<br />
  Sequence(<br />
    Single(Read), read =&gt;<br />
      Sequence(<br />
        Write(read), _ =&gt;<br />
          Value(read)))<br />
[/sourcecode]</p>
<p>This is the final form of our ADT, whereby a program can be one of three:</p>
<ul>
<li>Single: A single instruction.</li>
<li><code>Sequence</code>: A sequence of context-dependent programs.</li>
<li><code>Value</code>: A pure value (e.g. a <code>String</code>, <code>Int</code>, <code>MyFancyClass</code>, etc.)</li>
</ul>
<h3>Interpreter</h3>
<p>In order to update the interpreter, we just have to deal with our new type of IO programs.</p>
<p>[sourcecode language="scala"]<br />
def runProgram[A](program: IOProgram[A]): A =<br />
  program match {<br />
    case Single(e) =&gt; runEffect(e)<br />
    case Sequence(p, next) =&gt;<br />
      val res = runProgram(p)<br />
      runProgram(next(res))<br />
    case Value(a) =&gt; a<br />
  }<br />
[/sourcecode]</p>
<p>As you can see, this interpretation is fairly easy: a program <code>Value(a)</code> just means "returns a", which is what our interpreter does.</p>
<h3>Composition</h3>
<p>Last, we compose interpreter and pure function as usual to obtain a modular version of the original impure program:</p>
<p>[sourcecode language="scala"]<br />
def echo: String = runProgram(pureEcho)<br />
[/sourcecode]</p>
<h2>Conclusion</h2>
<p>This post aimed at showing that no matter how complex you impure programs are, you can always design a DSL to represent those programs in a purely declarative way. In our case, the DSL for building IO programs we ended up with is pretty expressive. In fact, we can represent any kind of imperative control flow with it. Try it!</p>
<p>There are, however, two major flaws we have still to deal with. First, we have to admit that the readability of programs written in the final <code>IOProgram</code> DSL is ... poor, to say the least. Second, there is a lot of boilerplate involved in the design of the <code>IOProgram</code> type. Indeed, no matter the type of DSL we are dealing with (based on IO instructions, File system operations, Web service calls, etc.), if we need imperative features, we will need to copy &amp; paste the same <code>Sequence</code> and <code>Value</code> cases. We leave the solution to these problems for the next and last post of this series!</p>
<p><strong>Edit:</strong> All code from this post can be found <a href="https://github.com/hablapps/gist/blob/master/src/test/scala/hello-monads/partII.scala" target="_blank">here</a>.</p>
