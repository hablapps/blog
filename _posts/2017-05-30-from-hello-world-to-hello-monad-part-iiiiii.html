---
layout: post
title: From "Hello, world!" to "Hello, monad!" (part III/III)
date: 2017-05-30 09:57:39.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Embedded DSLs
- functional programming
tags:
- Free
- Monads
- Syntactic sugar
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '43713691'
  geo_public: '0'
  _publicize_job_id: '5586176996'
author:
  login: juanmanuelserranohidalgo
  email: juanmanuel.serrano.hidalgo@gmail.com
  display_name: Juan
  first_name: Juan Manuel
  last_name: Serrano
permalink: "/2017/05/30/from-hello-world-to-hello-monad-part-iiiiii/"
---
<p>In the <a href="http://blog.hablapps.com/2016/01/22/from-hello-world-to-hello-monad-part-i/">first</a> part of this series, we saw how we can write the business logic of our applications as pure functions that return programs written in a custom domain-specific language (DSL). We also showed in <a href="https://blog.hablapps.com/2017/01/09/from-hello-world-to-hello-monad-part-iiiii/">part II</a> that no matter how complex our business logic is, we can always craft a DSL to express our intent. All this was illustrated using the "Fibonacci" example of purely functional programming, namely <em>IO programs</em>. We reproduce bellow the resulting design of the IO DSL and a sample IO program:</p>
<p>[sourcecode language="scala"]<br />
  // IO DSL</p>
<p>  sealed trait IOProgram[A]<br />
  case class Single[A](e: IOProgram.Effect[A])<br />
    extends IOProgram[A]<br />
  case class Sequence[A, B](p1: IOProgram[A],<br />
    p2: A =&gt; IOProgram[B]) extends IOProgram[B]<br />
  case class Value[A](a: A) extends IOProgram[A]</p>
<p>  object IOProgram{<br />
    sealed trait Effect[A]<br />
    case class Write(s: String) extends Effect[Unit]<br />
    case object Read extends Effect[String]<br />
  }</p>
<p>  // Sample IO program</p>
<p>  def echo(): IOProgram[String] =<br />
    Sequence(Single(Read()), (msg: String) =&gt;<br />
      Sequence(Write(msg), (_ : Unit) =&gt;<br />
        Value(msg)))<br />
[/sourcecode]</p>
<p>However, while this design is essentially correct from the point of view of the functional requirements of our little application, and from the point of view of illustrating the essence of functional programming, there are two major flaws concerning two important non-functional guarantees: readability and modularity. Let's start from the first one!</p>
<p><em>Note: you can find the code for this post in this <a href="https://github.com/hablapps/gist/blob/master/src/test/scala/hello-monads/partIII.scala">repo</a>. </em></p>
<h2>More sugar!</h2>
<p>What's the problem with the little <code>echo</code> function we came up with? Well, this function being pure has an essential advantage: it simply declares <i>what</i> has to be done, and the task of actually executing those programs in any way we want is delegated to another part of the application - the interpreter. Thus, we could run our <code>echo()</code> IO program using the <code>println</code> and <code>readLine</code> methods of the <code>Console</code>; or using an asynchronous library using <code>Future</code> values; or test it without the need of mocking libraries with the help of custom state transformers in a type-safe way. Great, great, great! But ... who would ever want to write our pure functions using that syntax? We have to admit that the readability of our little program is poor ... to say the least. Let's fix it!</p>
<h3>Smart constructors for atomic programs</h3>
<p>We start by adding some lifting methods that allow us to use <em>IO instructions</em> as if they were <em>programs </em>already:</p>
<p>[sourcecode language="scala"]<br />
object IOProgram {<br />
  object Syntax{<br />
    val read(): IOProgram[String] =<br />
      Single(Read)<br />
    def write(msg: String): IOProgram[Unit] =<br />
      Single(Write(msg))<br />
  }<br />
}<br />
[/sourcecode]</p>
<h3>Smart constructors for complex programs</h3>
<p>Next, let's introduce some smart constructors for sequencing programs. We will named them <code>flatMap</code> and <code>map</code> -- for reasons that will become clear very soon. As you can see in the following implementation, <code>flatMap</code> simply allow us to write sequential programs using an infix notation; and <code>map</code> allows us to write a special type of sequential program: one which runs some program, transforms its result using a given function, and then simply returns that transformed output.</p>
<p>[sourcecode language="scala"]<br />
sealed trait IOProgram[A]{<br />
  def flatMap[B](f: A =&gt; IOProgram[B]): IOProgram[B] =<br />
    Sequence(this, f)<br />
  def map[B](f: A =&gt; B): IOProgram[B] =<br />
    flatMap(f andThen Value.apply)<br />
}<br />
[/sourcecode]</p>
<p>Using all these smart constructors we can already write our program in a more concise style:</p>
<p>[sourcecode language="scala"]<br />
import IOProgram.Syntax._</p>
<p>def echo: IOProgram[String] =<br />
  read() flatMap { msg =&gt;<br />
    write(msg) map { _ =&gt; msg }<br />
  }<br />
[/sourcecode]</p>
<h3>Using for-comprehensions</h3>
<p>We may agree that the above version using smart constructors represents an improvement, but, admittedly, it's far from the conciseness and readability of the initial impure version:</p>
<p>[sourcecode language="scala"]<br />
def echo(): String = {<br />
  val msg: String = readLine<br />
  println(msg)<br />
  msg<br />
}<br />
[/sourcecode]</p>
<p>For one thing at least: in case that our program consists of a long sequence of multiple subprograms, we will be forced to write a long sequence of nested indented <code>flatMap</code>s. But we can avoid this already using so-called <em>for-comprehensions</em>! This is a Scala feature which parallels Haskell's <em>do</em> notation and F#'s <em>computation expressions</em>. In all of these cases, the purpose is being able to write sequential programs more easily. Our little example can be written now as follows:</p>
<p>[sourcecode language="scala"]<br />
import IOProgram.Syntax._</p>
<p>def echo(): IOProgram[String] = for{<br />
  msg &lt;- read()<br />
  _ &lt;- write(msg)<br />
} yield msg<br />
[/sourcecode]</p>
<p>For-comprehensions are desugared by the Scala compiler into a sequence of <code>flatMap</code>s and a last <code>map</code> expression. So, the above program and the <code>flatMap</code>-based program written in the last section are essentially identical.</p>
<h2>Hello, Monad!</h2>
<p>Let's deal now with the second of our problems: the one concerning modularity. What's the problem with the little DSL to write IO programs we came up with? Basically, the problem is that, approximately, half of this data type is not related to input-output at all. Indeed, if we were to write a different DSL to write imperative programs dealing with file system effects (e.g. reading the content from some file, renaming it, etc.), we would almost write line by line half of its definition:</p>
<p>[sourcecode language="scala"]<br />
sealed trait FileSystemProgram[A]<br />
case class Single[A](e: FileSystemProgram.Effect[A])<br />
  extends FileSystemProgram[A]<br />
case class Sequence[A, B](p1: FileSystemProgram[A],<br />
  p2: A =&gt; FileSystemProgram[B]) extends FileSystemProgram[B]<br />
case class Value[A](a: A) extends FileSystemProgram[A]</p>
<p>object FileSystemProgram{<br />
  sealed abstract class Effect[_]<br />
  case class ReadFile(path: String) extends Effect[String]<br />
  case class DeleteFile(path: String) extends Effect[Unit]<br />
  case class WriteFile(path: String, content: String)<br />
    extends Effect[Unit]<br />
}<br />
[/sourcecode]</p>
<p>The only remarkable change is related to the kinds of effects we are dealing with now: file system effects instead of IO effects. The definition of the DSL itself simply varies in the reference to the new kind of effect. This amount of redundancy is a clear signal of a lack of modularity. What we need is a generic data type that accounts for the common imperative features of both DSLs. We can try it as follows:</p>
<p>[sourcecode language="scala"]<br />
sealed trait ImperativeProgram[Effect[_],A]{<br />
  def flatMap[B](f: A =&gt; ImperativeProgram[Effect,B]) =<br />
    Sequence(this, f)<br />
  def map[B](f: A =&gt; B) =<br />
    flatMap(f andThen Value.apply)<br />
}<br />
case class Single[Effect[_],A](e: Effect[A])<br />
  extends ImperativeProgram[Effect,A]<br />
case class Sequence[Effect[_],A, B](<br />
  p1: ImperativeProgram[Effect,A],<br />
  p2: A =&gt; ImperativeProgram[Effect,B])<br />
  extends ImperativeProgram[Effect,B]<br />
case class Value[Effect[_],A](a: A)<br />
  extends ImperativeProgram[Effect,A]<br />
[/sourcecode]</p>
<p>Note how the <code>Single</code> variant of the DSL now refers to a (type constructor) parameter <code>Effect[_]</code>. We can now reuse the <code>ImperativeProgram</code> generic DSL in a modular definition of our DSLs for IO and file system effects:</p>
<p>[sourcecode language="scala"]<br />
type IOProgram[A] =<br />
  ImperativeProgram[IOProgram.Effect, A]</p>
<p>type FileSystemProgram[A] =<br />
  ImperativeProgram[FileSystemProgram.Effect, A]<br />
[/sourcecode]</p>
<p>This <code>ImperativeProgram</code> generic DSL seems pretty powerful: indeed, it encodes the essence of imperative DSLs, and it is actually commonly known through a much more popular name: <em>Free Monad</em>! The definitions of <code>Free</code> that you will find in professional libraries such as <a href="https://github.com/typelevel/cats/blob/master/free/src/main/scala/cats/free/Free.scala#L13" target="_blank" rel="noopener noreferrer">cats</a>, <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Free.scala#L102" target="_blank" rel="noopener noreferrer">scalaz</a> or <a href="https://github.com/atnos-org/eff/blob/master/shared/src/main/scala/org/atnos/eff/Eff.scala#L50" target="_blank" rel="noopener noreferrer">eff</a> are not quite the same as the one obtained in this post, which is quite inefficient both in time and space (not to mention further modularity problems when combining different types of effects); but, the essence of free monads, namely, being able to define imperative programs given <em>any</em> type of effects represented by some type constructor is there. This substantially reduces the effort of defining an imperative DSL: first, program definition will collapse into a single type alias; second, we will get the <code>flatMap</code> and <code>map</code> operators for free; and, similarly, although not shown in this post, we will also be able to simplify the definition of monadic interpreters (those that translate the given free program into a specific monadic data type, such as a state transformation, asynchronous computation, etc.), amongst many other goodies.</p>
<h2>Conclusion: modularity all the way down!</h2>
<p>We may say that the essence of functional programming is <em>modularity</em>. Indeed, the defining feature of functional programming, namely <em>pure functions</em>, is an application of this design principle: they let us compose our application out of two kinds of modules: pure functions themselves that declare what has to be done, and interpreters that specify a particular way of doing it. In particular, interpreters may behave as translators, so that the resulting interpretations are programs written in a lower-level DSL, that also need to be interpreted. Eventually, we will reach the "bare metal" and the interpreters will actually bring the effects into the real world (i.e. something will be written in the screen, a file will be read, a web service will be called, etc.).</p>
<p>But besides pure functions, functional programming is full of many additional modularity techniques: parametric polymorphism, type classes, higher-order functions, lazy evaluation, datatype generics, etc. All these techniques, which were first conceived in the functional programming community, basically aim at allowing us to write programs with extra levels of modularity. We saw an example in this post: instead of defining imperative DSLs for implementing Input/Output and File System programs in a monolithic way, we were able to abstract away their differences and package their common part in a super reusable definition: namely, the generic imperative DSL represented by the Free monad. How did we do that? Basically, using parametric polymorphism (higher-kinds generics, in particular), and generalised algebraic data types (GADTs). But functional programming is so rich in abstractions and modularity techniques, that we may have even achieved a similar modular result using type classes instead of GADTs (in a style known as <em>finally tagless</em>). And this is actually what we will see in our next post. Stay tuned!</p>
