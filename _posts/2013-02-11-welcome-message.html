---
layout: post
title: Welcome message
date: 2013-02-11 18:39:24.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Embedded DSLs
- Habla Computing
- Scala
- Speech
tags: []
meta:
  _edit_last: '43713691'
  draftfeedback_requests: a:1:{s:32:"habla-computing@googlegroups.com";a:3:{s:3:"key";s:13:"5116b10b51b0a";s:4:"time";s:10:"1360441611";s:7:"user_id";s:8:"43713691";}}
  draft_feedback: "a:1:{s:32:\"habla-computing@googlegroups.com\";a:4:{i:0;a:2:{s:4:\"time\";s:10:\"1360586675\";s:7:\"content\";s:657:\"
    Yo eliminaría social networks, ya están dentro de Web 2.0 apps??\n\nSimilarly,
    factories, facades, monads, etc., are alien to domain experts and non-IT people.
    Y esto no está lejos de los requisitos o no entiendo bien pq es importante que
    conozcan los no it los patrones de diseño??\n\nThat aim at simplifying or that
    try to aim at simplifying??\n\nbetw\e\eeen sale con dos flechas antes de non-IT
    people.\n\nwe claim Speech designs to be directly understandable by functional
    experts un poco redundante con lo anterior y no dice nada de la suite de herramientas\n\nSpeech
    has been designed as a PROGRAMMING LANGUAGE\n\nYOUR FEEDBACK IS REALLY IMPORTANT
    FOR US\n\n\n\n\n\n\";}i:1;a:2:{s:4:\"time\";s:10:\"1360590613\";s:7:\"content\";s:190:\"
    - Añadir pequeñas subsecciones para evitar todos los parrafos \"a cholón\" (What
    we do..., How we do, o algo así).\n\n- Lo de Welcome message no incita mucho a
    la lectura del Ipsum Dolorem.\";}i:2;a:2:{s:4:\"time\";s:10:\"1360596545\";s:7:\"content\";s:211:\"Me
    ha gustado...me sonaba mucho todo por la reunión de esta mañana.\n\nPondría un
    hiper-enlace a nuestra web cuando mencionas Habla Computing en el tercer párrafo.\n\nY
    poco más...a mi me has convencido.\n\nDavid\";}i:3;a:2:{s:4:\"time\";s:10:\"1360597139\";s:7:\"content\";s:613:\"
    Hola Juanma,\n\nVeo muy adecuado el artículo, tanto desde el punto de vista gramatical
    como del punto de vista técnico. \n\nEn cuanto a la estructura, pienso que es
    correcta ya que comienza con la exposición del problema y de lo que hace Speech,
    aprovechando para enlazar con lo que hemos visto esta mañana, la diferencia entre
    el lenguaje natural y el lenguje técnico, pasando a exponer las ventajas que supondrá.\n\nComo
    punto de partida y apoyo a la presentación de Speech, quizás enfatizaría el hecho
    de la reducción de tiempo y coste, para atraer a posibles personas y despertar
    su interés.\n\nUn saludo,\";}}}"
  _publicize_pending: '1'
  _oembed_c5162c0ad2f55344ad0a1d149ad67d5d: "{{unknown}}"
  _oembed_b6feba44a087ffeb0e0026a3a9cdf3c1: "{{unknown}}"
  _oembed_b4b2671fe2f17f1ec5d5a8ae15404df2: "{{unknown}}"
  _oembed_ef8c6cf4b45a4d61a12e5d89e8bb9ac9: "{{unknown}}"
author: Juan Manuel Serrano
permalink: "/2013/02/11/welcome-message/"
---
<p>Think of information systems, Web 2.0 apps, games, e-learning, e-commerce, and the rest of e-* applications. Certainly, these application domains differ significantly in several respects, but can we find some commonalities? We do think so: they deal directly with people; they are deeply concerned with their needs for communication, collaboration and coordination; they all can be regarded as <strong>social apps</strong>. If we have a look to their functional requirements, we will invariably find <em>people</em> playing different <em>roles, saying</em> things to one another, <em>seeing</em> what is happening, generating and consuming <em>information,</em> and so forth; moreover, we will also notice how the application must take into account different normative concerns: <em>permissions</em> to do something, <em>commitments</em> endorsed by particular role players, <em>monitoring</em> rules, etc.</p>
<p>How are these applications developed nowadays? Programmers mainly use object- and functional-oriented programming languages, such as Java, C#, Scala, Haskell, etc. Yet, <em>functions</em> and <em>objects</em> are quite apart from the kinds of<em> social</em> abstractions we just mentioned above. Similarly, <em>factories, facades, monads,</em> etc., are alien to domain experts and non-IT people. The likely result: a daunting amount of accidental complexity leaked into the code. Clearly, if we want to strive for <strong>purely functional</strong> code, i.e. software which directly encode the functional requirements of the application, we have to raise the level of abstraction supported by the programming language.</p>
<p><strong><em>Towards social-oriented programming ... </em></strong></p>
<p>In <a href="http://www.hablapps.com">Habla Computing</a> we are building <strong>Speech,</strong> a domain-specific programming language for implementing the domain logic of social apps. Speech offers the programmer computational counterparts of social concepts such as roles, speech acts, interaction contexts, commitments, permissions, and the like, which aim at closing the gap between natural-language functional requirements and executable code. The net result of this higher-level of abstraction is a drastic reduction in lines-of-code, development times and cost, as well as a significant increase in quality. Of course, we are not alone in this quest for functional purity: the current landscape abounds with domain-specific proposals that aim at simplifying the implementation of business processes, vertical social networks, etc.</p>
<p>Two features, however, distinguish Speech from BPMS, social networking engines, and other domain-specific technologies. First, Speech is not confined to niche domains; do your functional requirements deal directly with people? If so, you can profit from Speech, regardless of the kind of social process supported by the application. Second, Speech is a language for programmers; it is neither a modeling language for business analysts, nor a suite of tools that cope with each functional concern separately. Certainly, we aim at bridging the gap between non-IT people and programmers, and we claim Speech designs to be directly understandable by functional experts. But programmers need a self-sufficient, cohesive and expressive language. Thus, besides being a domain-specific technology, Speech has been designed as a programming language which takes into account every functional concern in a modular and cohesive way. Moreover, in order to foster adoption of Speech in the programming language community, we've decided to offer Speech as an <em>embedded DSL</em>, rather than as a stand-alone implementation.</p>
<p><strong><em>... embedded in Scala!</em></strong></p>
<p>There are several very good languages which enable an embedded implementation strategy, but we finally chose <strong>Scala</strong>. We especially like its mix of functional and object-oriented features, and love its new experimental ones: macros turned out essential for us. This blog will allow us to unveil the major challenges we faced in implementing Speech, and how Scala helped us to solve them. We strive for functional-programming purity in our codebase, so the title of this blog also appeals to that leitmotiv. In this regard, topics that will eventually arise include: coping with updates of immutable objects within generic contexts; dealing with references to evolving immutable objects; etc. Some of these issues lead us to develop general-purpose libraries that we've planned to open-source. We are open to suggestions and recommendations for improvements, and any other form of collaboration. Your feedback is really important to us.</p>
<p>We will also use this blog to announce the release of our products. We are working against the clock to launch the beta release of the Speech interpreter in the following weeks. So, we expect to contact you again very soon. Finally, this blog will also give us the opportunity to advertise our participation in different events. One of these events will take place on 10th-13th April at Cambridge, UK: join us at <a href="http://www.codegeneration.net" target="_blank">Code Generation 2013</a>!</p>
