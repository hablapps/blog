---
layout: post
title: Algebras for the Masses!
date: 2017-02-20 18:47:51.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '35663564'
  geo_public: '0'
  draftfeedback_requests: a:1:{s:13:"5874f2cfcde2a";a:3:{s:3:"key";s:13:"5874f2cfcde2a";s:4:"time";s:10:"1484059343";s:7:"user_id";s:8:"35663564";}}
  _publicize_job_id: '2066845134'
  _publicize_done_external: a:1:{s:7:"twitter";a:1:{i:15919025;s:51:"https://twitter.com/jeslg/status/833734944396603392";}}
  _publicize_done_16092269: '1'
  _wpas_done_15919025: '1'
  publicize_twitter_user: jeslg
author: Jesus Lopez-Gonzalez
permalink: "/2017/02/20/algebras-for-the-masses/"
---
<p>According to Wikipedia, <em>"an <a href="https://en.wikipedia.org/wiki/Algebraic_structure">Algebraic Structure</a> is a set with one or more finitary operations defined on it that satisfies a list of axioms"</em>. From a programming perspective, that sounds like a bunch of methods defined on a type. In fact, we can find many of those algebras represented as <em>type classes</em> in libraries such as <em>scalaz</em> or <em>cats</em>. This way of representing algebras is pretty related to <a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf"><em>object algebras</em></a>. However, it's quite common to hear about <a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras"><em>F-algebras</em></a> as well, an abstraction that arises from the field of <em>Category Theory</em>. Today, we'll see not only that both representations are isomorphic, but also how to systematically generate conversions between them. To validate those transformations, we'll scratch the surface of <a href="https://github.com/slamdata/matryoshka">Matryoshka</a> to fold several expressions with the aforementioned algebra representations. So here we go!</p>
<h2>Algebras and Their Representations</h2>
<p>Undoubtedly, one of the most widespread algebraic structures in the functional programming community is <em>monoid</em>. Despite its simplicity, it turns out to be <a href="http://repository.upenn.edu/cgi/viewcontent.cgi?article=1773&amp;context=cis_papers">very powerful</a>. Typically, in Scala type class libraries, monoid is represented as follows:</p>
<p>[code lang=scala]<br />
trait OMonoid[A] {<br />
  def mzero(): A<br />
  def mappend(a1: A, a2: A): A<br />
}<br />
[/code]</p>
<p>This type class is what is known as the <em>object algebra interface</em>, an interface of an abstract factory to create expressions. It contains two methods: <code>mzero</code> and <code>mappend</code> which correspond with the two operations that describe this particular algebra. Once we have created the algebra interface, we could provide instances for it, that are also known as <em>object algebras</em>. A common monoid instance is <em>sum</em>:</p>
<p>[code lang=scala]<br />
val sumOMonoid: OMonoid[Int] = new OMonoid[Int] {<br />
  def mzero(): Int = 0<br />
  def mappend(a1: Int, a2: Int): Int = a1 + a2<br />
}<br />
[/code]</p>
<p>Once we have shown object algebra fundamentals, it's time to focus on F-algebras. This is a really simple abstraction that consists of a <em>Functor</em> <code>F[_]</code>, a <em>carrier</em> type <code>A</code> and an algebra <em>structure</em> (the function itself):</p>
<p>[code lang=scala]<br />
type FAlgebra[F[_], A] = F[A] =&gt; A<br />
[/code]</p>
<p>At first glance, this looks very different from the object algebra approach for monoids. However, as we will see, the translation is completely natural. Indeed, this representation just packs all the algebra operations into a unique function. Thereby, the major challenge here is to identify the corresponding functor for monoids, which is an Algebraic Data Type with a representative for every operation conforming the algebra. We refer to it as the algebra signature:</p>
<p>[code lang=scala]<br />
sealed trait Σ[A]<br />
case class MZero[A]() extends Σ[A]<br />
case class MAppend[A](a1: A, a2: A) extends Σ[A]<br />
[/code]</p>
<p>Once the functor is defined, we can modularize Monoid as an F-algebra:</p>
<p>[code lang=scala]<br />
type FMonoid[A] = FAlgebra[Σ, A]<br />
[/code]</p>
<p>Finally, we could provide a <em>sum</em> instance for the brand new monoid representation, as we did with the previous approach:</p>
<p>[code lang=scala]<br />
val sumFMonoid: FMonoid[Int] = {<br />
  case Mzero() =&gt; 0<br />
  case Mappend(a1, a2) =&gt; a1 + a2<br />
}<br />
[/code]</p>
<p>We claim that <code>sumFMonoid</code> is isomorphic to <code>sumOMonoid</code>. In order to provide such an evidence, we show the isomorphism between <code>OMonoid</code> and <code>FMonoid</code>:</p>
<p>[code lang=scala]<br />
val monoidIso = new (OMonoid &lt;~&gt; FMonoid) {</p>
<p>  val to = new (OMonoid ~&gt; FMonoid) {<br />
    def apply[A](omonoid: OMonoid[A]) = {<br />
      case Mzero() =&gt; omonoid.mzero<br />
      case Mappend(a1, a2) =&gt; omonoid.mappend(a1, a2)<br />
    }<br />
  }</p>
<p>  val from = new (FMonoid ~&gt; Monoid) {<br />
    def apply[A](fmonoid: FAlgebra[Σ, A]) = new FMonoid[A] {<br />
      def mzero = fmonoid(Mzero())<br />
      def mappend(a1: A, a2: A) = fmonoid(Mappend(a1, a2))<br />
    }<br />
  }<br />
}<br />
[/code]</p>
<p><em>(*) Notice that we have ignored the monoid laws along the article for simplicity, but keep in mind that they constitute a fundamental part of every algebra.</em></p>
<p>Given this situation, the question we should be asking is: <em>"What is the best algebra representation for us?"</em> Sadly, there's no clear answer to this. On the one hand, there is F-algebra. Undoubtedly, this representation is more modular. In fact, it is used in projects such as <a href="https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/package.scala#L55">Matryoshka</a>, a library of recursion-schemes that is able to generate fixed points for any <code>Functor</code>, or define a generic <a href="https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L35">catamorphism</a> (or <code>fold</code>) <em>once and for all</em>, which works for any F-algebra. On the other hand, there is the object algebra representation, closer to the widespread <em>programming interfaces</em>, that we can find in libraries such as <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Monoid.scala#L20">scalaz</a> or <a href="https://github.com/typelevel/cats/blob/155f7f534993c30d6e757de990330ac796dad5da/kernel/src/main/scala/cats/kernel/Monoid.scala#L11">cats</a>. Although not as modular as F-algebras, this representation is powerful enough to interpret algebra expressions with little effort. See <a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf">this paper</a> on shallow embedding to get a better intuition on that. Therefore, both representations do appear in prominent libraries of the functional programming community. Wouldn't it be nice to have them coexisting?</p>
<h2>Macro <code>@algebra</code> to Provide Conversions</h2>
<p>As we have seen in the previous section, turning object algebras into F-algebras (and viceversa) is straightforward. Besides, we noticed that both algebra representations are used in everyday programming. For all these reasons, we decided to code an <a href="https://github.com/hablapps/azucar/blob/master/src/main/scala/macros/algebra.scala#L7">experimental macro</a> (<code>@algebra</code>) to make both representations live together. The macro annotation can be applied to an object algebra Interface:</p>
<p>[code lang=scala]<br />
@algebra trait OMonoid[A] {<br />
  def mzero(): A<br />
  def mappend(a1: A, a2: A): A<br />
}<br />
[/code]</p>
<p>This annotation removes boilerplate by automatically <a href="https://gist.github.com/jeslg/bf1163433698be5e50375dab93e5e075">generating some F-algebra encodings</a>. They should enable us to translate object algebras wherever an F-algebra is required. To check that behaviour, we're going to invoke a Matryoshka <em>catamorphism</em> (<code>cata</code>) that requires an F-algebra as input parameter, but we'll be implementing object algebras instead. Besides, we'll be using the <a href="https://github.com/slamdata/matryoshka#introduction">tiny language</a> (num literals and multiplications) that is used in Matryoshka's introduction, so we recommend the reader to glance at it before moving ahead. Then, you should be able to appreciate that <code>Expr</code> leads to the following object algebra interface:</p>
<p>[code lang=scala]<br />
@algebra trait ExprAlg[A] {<br />
  def num(value: Long): A<br />
  def mul(l: A, r: A): A<br />
}<br />
[/code]</p>
<p>First of all, <a href="https://gist.github.com/jeslg/9f9534a3a37b772e953d727a4e661039">our macro has to generate</a> the corresponding <code>Expr</code> signature. So, our auto generated companion for <code>ExprAlg</code> will contain:</p>
<p>[code lang=scala]<br />
sealed abstract class Σ[_]<br />
case class Num[A](value: Long) extends Σ[A]<br />
case class Mul[A](l: A, r: A) extends Σ[A]<br />
[/code]</p>
<p>In <a href="https://github.com/slamdata/matryoshka#algebras">this section</a> from Matryoshka's introduction, we see that it's required to provide a functor for <code>Expr</code> prior to apply a <code>cata</code>. Our macro is able to derive the Functor instance for <code>Σ</code>, so we don't have to worry about that. The document shows also an <code>eval</code> F-algebra, that we can translate easily to an object algebra:</p>
<p>[code lang=scala]<br />
implicit def eval = new Expr[Long] {<br />
  def num(value: Long) = value<br />
  def mul(l: Long, r: Long) = l * r<br />
}<br />
[/code]</p>
<p>Notice that we marked it as <code>implicit</code>, because it will be necessary for the next task, which is invoking the catamorphism over an expression. Firstly, we need to declare the expression to be folded, I mean, evaluated. We can copy <code>someExpr</code> as is, and it will compile smoothly, since the <code>Mul</code> and <code>Num</code> case classes are generated by the macro as well:</p>
<p>[code lang=scala]<br />
def someExpr[T](implicit T: Corecursive.Aux[T, Σ]): T =<br />
  Mul(Num[T](2).embed, Mul(Num[T](3).embed,<br />
    Num[T](4).embed).embed).embed<br />
[/code]</p>
<p>Finally, we can invoke the <code>cata</code>. As we noted previously, it requires an F-algebra as input. Thereby, we use the <code>FAlgebra</code> summoner, generated by the macro, that detects the implicit <code>eval</code> and turns it into a compatible F-algebra to feed the function.</p>
<p>[code lang=scala]<br />
someExpr[Mu[Σ]].cata(FAlgebra[Long]) // ⇒ 24<br />
[/code]</p>
<p>To sum up, we applied our macro annotation to <code>ExprAlg</code> to generate some utilities to deal with F-algebras. Then, we defined our <code>eval</code> as an object algebra. As the generated encodings knew how to turn it into a F-algebra, we could invoke Matryoshka's <code>cata</code> with this algebra safely. Thus, we reach our objective of making both representations coexist nicely.</p>
<h2>Future Work</h2>
<p>Today, we have seen <code>OMonoid[A]</code> and <code>ExprAlg[A]</code> as algebra examples, both demanding a concrete type parameter. However, there are algebras that are parametrized by a type constructor. Take <code>Monad[F[_]]</code> as an example. In this particular situation, we can't generate isomorphisms with F-algebras as we know them. Instead, we have to deal with F-algebras for <a href="http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html">Higher Order Functors</a>. Our macro <code>@algebra</code> is able to detect GADTs and generate the corresponding encodings. This is still very experimental, but you can find <a href="https://github.com/hablapps/azucar/blob/master/src/test/scala/hk/AlgebraTest.scala">an example here</a>.</p>
<p>By now, we have placed <code>@algebra</code> in <a href="https://github.com/hablapps/azucar"><em>azucar</em></a> (spanish word for "sugar"), a library where we plan to deploy more utilities to deal with (co)algebras. If you have some feedback or suggestion to improve it, we'd be very glad to hear from you. Anyway, we hope you've enjoyed reading!</p>
