---
layout: post
title: Updating immutable objects in generic contexts
date: 2013-03-07 11:26:17.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- case classes
- immutability
- Macros
- Scala
- Speech
- Type Class
- Updatable
tags: []
meta:
  _edit_last: '43713691'
  draftfeedback_requests: a:1:{s:13:"5135dc82cfb35";a:3:{s:3:"key";s:13:"5135dc82cfb35";s:4:"time";s:10:"1362484354";s:7:"user_id";s:8:"43713691";}}
  draft_feedback: "a:1:{s:13:\"5135dc82cfb35\";a:6:{i:0;a:2:{s:4:\"time\";s:10:\"1362487399\";s:7:\"content\";s:454:\"typo:
    (dthink of the Speech member attribute as a kind of standard attribute) --> think
    of the Speech....\n\nthe most \"ugly\" part --> the \"ugliest\" part\n\nThe Speech
    layer is populated by several abstract types with dozens of standard attributes,
    and making the application programmer to provide getters and setters for *then
    \  --->  *them\n\n--------------------\nEstá muy bien. Fácil de entender, incluso
    para mí, que no tengo ni idea de escala. Congrats!\";}i:1;a:2:{s:4:\"time\";s:10:\"1362488374\";s:7:\"content\";s:1143:\"Categoría:
    añadir\n\nEstá todo bien, se entiende muy bien y seguro que les abre los ojos
    a muchos en signo de aprobación!\n\nTypos:\n\n[...] in popular scala libraries
    such as scalaz [...] -> scala / Scala\n[...] case classes and elliminating all
    this boilerplate? [...] -> elliminating / eliminating\n[...] you can find it on
    Github. [...] -> Github / GitHub\n[...] think of twitter: [...] -> twitter / Twitter\n[...]
    The following snippet uses the twitter [...] -> twitter / Twitter\n[...] The twitter
    layer simply [...] -> twitter / Twitter\n[...] (dthink of the Speech member attribute
    as a kind of standard attribute) [...] -> dthink / think\n[...] of the twitter
    types – using case classes [...] -> twitter / Twitter\n[...] Now, this is the
    most “ugly” part: [...] -> the most \"ugly\" / the \"ugliest\"\n[...] how the
    Speech and twitter layers [...] -> twitter / Twitter\n[...] If you want to elliminate
    that warning, [...] -> elliminate / eliminate\n[...] applications of the updatable
    package in latter posts, [...] -> latter / other (latter es \"último\", cuando
    te refieres a \"el primero de... el último de... sería mejor elegir otra palabra)\";}i:2;a:2:{s:4:\"time\";s:10:\"1362492251\";s:7:\"content\";s:447:\"Hola
    Juanma!,\n\nen primer lugar hay algunos errores en palabras. Creo haber visto
    un \"elliminate\" y un \"dthink\".\n\nPor otro lado he estado leyendo el artículo
    y creo que está bastante bien eso de poner el problema, una posible solución y
    luego meter los updatables como una buena alternativa. No soy un experto en estos
    follones pero tras leerlo he entendido prácticamente todo.\n\nFelicitaciones desde
    el otro lado de la pared.\n\nUn saludo,\n\nDavid\";}i:3;a:2:{s:4:\"time\";s:10:\"1362495492\";s:7:\"content\";s:339:\"Creo
    que está muy bien. La única pega, que puede dar la impresión de que utilizar las
    case classes no es realmente tan pesado (por la pinta que tienen los snippets).\n
    \nY alguna corrección ortográfica:\n- \"def macros\" => \"the macros\"?\n- \"dthink\"
    => \"think\"\n- \"The weakBuilder macro generate\" => \"generateS\"\n- \"ellimilate\"
    => \"eliminate\"\";}i:4;a:2:{s:4:\"time\";s:10:\"1362495945\";s:7:\"content\";s:203:\"Está
    muy bien, me ha gustado bastante. El único typo que creo que hay es \"is tough
    work\". ¿No sería \"is a tough work\"? Por lo demás, mi inglés no da para más,
    me parece que está muy bien escrito.\";}i:5;a:2:{s:4:\"time\";s:10:\"1362496075\";s:7:\"content\";s:20:\"
    No entiendo nada!!!\";}}}"
  _publicize_pending: '1'
author: Juan Manuel Serrano
permalink: "/2013/03/07/updating-immutable-objects-in-generic-contexts/"
---
<p>Immutability is one of the hallmarks of functional design, and writing idiomatic programs in Scala highly relies on manipulating immutable objects. Now, if we don't have mutable fields (aka <em>vars</em>) ... how can we update objects in a convenient way? Scala provides so-called <em>case classes</em> which have a <em>copy</em> method with the required functionality. And we can also use <em>lenses</em>, a higher-level abstraction that you can find in popular Scala libraries such as <a href="https://github.com/scalaz/scalaz">scalaz</a> and <a href="https://github.com/milessabin/shapeless">shapeless</a> (you can find a macro-based implementation in the <a href="https://github.com/retronym/macrocosm">macrocosm</a> project as well). Nevertheless, all these implementations build some way or another upon case classes as the basic updating mechanism.</p>
<p>Now, sometimes writing case classes for your specification traits is cumbersome, since it involves a lot of boilerplate. And this problem is specially exacerbated in the presence of inheritance hierarchies, where traits get also polluted with getters and setters. Wouldn't it be nice if we found some way of automatically deriving case classes and eliminating all this boilerplate? Well, this is a question for macros, and <em><a href="http://docs.scala-lang.org/overviews/macros/typemacros.html">type macros</a>, </em>in particular. But type macros are still a pre-release feature of Scala. So, what can be done with <a href="http://docs.scala-lang.org/overviews/macros/overview.html"><em>def macros</em></a> alone? We have developed a library that exploits def macros in combination with reflective calls to eliminate the need of writing implementation classes. And it allows the programmer to update immutable objects in generic contexts with a minimum overhead. This library is called <a href="https://github.com/hablapps/updatable"><strong>org.hablapps.updatable</strong></a> and you can find it on GitHub. Before explaining its functionality, though, let's illustrate the problem with a simple example, and let's solve it using case classes.</p>
<h3><strong><em>The problem ...</em></strong></h3>
<p>We will illustrate the kind of updating problem we have to deal with by considering a design problem in the implementation of Speech itself. Among other things, our DSL offers to programmers an abstract layer which implements generic types and state transformations that can be reused across any kind of social domain. For instance, the layer includes <em>interaction contexts </em>and <em>agent roles</em>, and the <em>play</em> transformation which adds a new agent role within some context. We want to implement interaction contexts and agent roles as immutable objects and be able to reuse the <em>play </em>transformation as-is, across any application domain. For instance, think of Twitter: there you find accounts, followers, tweeters, and many other concepts. We can think of accounts as the contexts where tweeters interact with their followers; and following someone would involve <em>playing </em>a new follower role within their account. As another example, think of courses as contexts of interaction for student and teacher agents, and some student enrolling some course: this action can also be implemented with the help of the <em>play </em>action.</p>
<h3><em><strong>... Solved using case classes</strong></em></h3>
<p>Our design problem can be understood as a particular example of the<em><a href="http://www.scala-lang.org/sites/default/files/odersky/ScalableComponent.pdf"> family polymorphism</a> </em>problem, which can be easily solved in Scala using abstract types and the <em>cake </em><em>pattern. </em>Accordingly, the Speech abstraction layer can be understood as a family of types which vary together covariantly in each application layer. In particular, our implementation will be structured in three basic layers:</p>
<ul>
<li>An abstract layer (the <em>S</em><em>peech</em> layer) which provides generic implementations of interactions contexts, agents, and generic transformations, in terms of traits and generic methods.</li>
<li>An application layer which provides specific implementations of domain-dependent concepts in terms of traits that extends the corresponding generic traits.</li>
<li>Another application layer which provides the implementation of domain-dependent traits, in terms of case classes.</li>
</ul>
<p>The following snippet represents an implementation sketch of the first layer:</p>
<p>[sourcecode language="scala"]<br />
trait Speech {<br />
  trait Interaction[This &lt;: Interaction[This]] { self: This =&gt;<br />
    type Member &lt;: Agent[Member]<br />
    def member: Set[Member]<br />
    def member_=(agent: Set[Member]): This<br />
  }</p>
<p>  trait Agent[This &lt;: Agent[This]] { self: This =&gt;<br />
  }</p>
<p>  def play[I &lt;: Interaction[I]](i: I)(a: i.Member): I =<br />
    i.member = i.member + a<br />
}<br />
[/sourcecode]</p>
<p>Here, the Speech layer just implements two traits for the <em>Interaction </em>and <em>Agent </em>types, as well as the <em>play </em>transformation. Note that the <em>play </em>method must work for any type of interaction and agent, and we don't want to forget the exact type of interaction once we call the method. Hence, the method is parameterized with respect to some interaction type <em>I</em>. Now, the agent to be played within that context must be compatible with the interaction type, i.e. we can play <em>followers </em>within Twitter accounts, but not <em>students. </em> To account for this constraint, we declare an abstract type <em>Member </em>in the <em>Interaction </em>trait and exploit dependent types in the <em>play </em>signature. How do we add the new member agent? We need a setter, of course. And this setter must also return the specific type of the interaction <em></em>(again, to avoid type information loss). For that purpose, the trait is parameterized with the <em>This </em>parameter, following the standard <a href="http://www.scala-lang.org/node/6649#comment-27573">solution</a> to this problem. Last, note the updated sentence in the <em>play </em>method: it's as if <em>member </em>was a <em>var</em>. But it's not, it's simply that we named the getter and setter according to the <em>var </em>convention.</p>
<p>How do we reuse this abstract layer? The following snippet uses the Twitter domain to illustrate reuse of the Speech layer.</p>
<p>[sourcecode language="scala"]<br />
trait Twitter extends Speech {</p>
<p>  trait Account extends Interaction[Account] {<br />
    type Member = Follower<br />
  }</p>
<p>  def Account(members: Set[Follower] = Set()): Account</p>
<p>  trait Follower extends Agent[Follower] {<br />
  }</p>
<p>  def Follower(): Follower<br />
}<br />
[/sourcecode]</p>
<p>The Twitter layer simply extends the Speech traits and sets the abstract members to the desired values. Of course, a real implementation will include additional <em>domain-dependent</em> attributes, methods, etc., to the <em>Account </em>and <em>Follower</em> traits (think of the Speech <em>member</em> attribute as a kind of <em>standard</em> attribute). Note that we also included factory methods for the <em>Account</em> and <em>Follower</em> types. In a real implementation, it is more than likely that we will need them. And we don't want to commit to any specific implementation class, so we declare them abstract. The next portion of the cake will provide the implementations of the Twitter types - using case classes:</p>
<p>[sourcecode language="scala"]<br />
  trait TwitterImpl { self: Twitter =&gt;</p>
<p>    private case class AccountClass(member: Set[Follower]) extends Account {<br />
      def member_=(agent: Set[Follower]) = copy(member = agent)<br />
    }</p>
<p>    def Account(members: Set[Follower] = Set()): Account = AccountClass(members)</p>
<p>    private case class FollowerClass() extends Follower {<br />
    }</p>
<p>    def Follower(): Follower = FollowerClass()<br />
  }<br />
[/sourcecode]</p>
<p>Now, this is the "ugliest" part: we had to provide case classes for all the application traits, and the getters/setters for all of their attributes (standard and non-standard). In this simple example, we just have the "member" attribute, but we may have dozens in a real implementation. This implementation layer must also provide implementations for factory methods, which happen to be the only way to create new entities (note the <em>private</em> declaration of case classes).</p>
<p>The following snippet exercises the above implementation:</p>
<p>[sourcecode language="scala"]<br />
  object s extends Twitter with TwitterImpl<br />
  import s._</p>
<p>  val (a, f1, f2) = (Account(), Follower(), Follower())</p>
<p>  // test _=<br />
  assert((a.member = Set()).member == Set())<br />
  assert((a.member = Set(f1, f2)).member == Set(f1, f2))</p>
<p>  // test play<br />
  val a1 = play(a)(f1)<br />
  assert(a1.member == Set(f1))<br />
[/sourcecode]</p>
<h2> <em>... <strong>Solved using the </strong></em>org.hablapps.updatable<em><strong> package</strong></em></h2>
<p>The major structural change to the above implementation is that we don't need the <em>case</em> <em>class</em> layer. Thus, we may qualify the following implementation as <em>trait-oriented</em>. Let's see how the Speech and Twitter layers are modified:</p>
<p>[sourcecode language="scala"]<br />
trait Speech {<br />
  trait Interaction {<br />
    type Member &lt;: Agent<br />
    val member: Set[Member]<br />
  }</p>
<p>  implicit val Interaction = weakBuilder[Interaction]</p>
<p>  trait Agent {<br />
  }</p>
<p>  implicit val Agent = weakBuilder[Agent]</p>
<p>  def play[I &lt;: Interaction: Builder](i: I)(a: i.Member): I =<br />
    i.member := i.member + a<br />
}<br />
[/sourcecode]</p>
<p>The first noticeable change is that ... we don't need getters and setters! We just declared our attributes using <em>val</em>s. And the implementation of the <em>play </em>method has not been excessively complicated: we just substituted the "=" operator for the new operator ":=", and included through its signature evidence that the type parameter <em>I</em> has an implementation of the <em>Builder</em> type class. Instances of this type class can be understood as factories that allow programmers to instantiate and update objects of the specified type in a very convenient way. In particular, the Builder type class enables an implicit macro conversion which gives access to the ":=" operator. All this in a type-safe way.  In a sense, builders play the same role as case classes played in the previous implementation. But there is a crucial difference: builders are created automatically through the <em>builder </em>macro, as shown in the following snippet of the second layer:</p>
<p>[sourcecode language="scala"]<br />
  trait Twitter extends Speech {<br />
    trait Account extends Interaction {<br />
      type Member = Follower<br />
    }</p>
<p>    implicit val Account = builder[Account]</p>
<p>    trait Follower extends Agent {<br />
    }</p>
<p>    implicit val Follower = builder[Follower]<br />
  }<br />
[/sourcecode]</p>
<p>The only difference in this layer with respect to the case class implementation is that no method factories are needed, since builders play that role. Now, if you come back to the previous snippet you will also notice <em>weakBuilder</em> invocations for types <em>Interaction </em>and <em>Agent</em>. Certainly, we don't need strict builders for these types, since they are "abstract". However, builders also provide attribute reifications, and we certainly want an unique reification for the <em>member </em>attribute. The <em>weakBuilder </em>macro generates the corresponding reifications. The following snippet shows how to access reified attributes, and mimic the functionality included in the case class implementation.</p>
<p>[sourcecode language="scala"]<br />
object s extends Twitter<br />
import s._</p>
<p>// test reifications<br />
assert(Account.attributes == List(Account._member))</p>
<p>// create instances<br />
val (a, f1, f2) = (Account(), Follower(), Follower())</p>
<p>// test _=<br />
assert(a.member == Set())<br />
assert(((a.member += f2).member -= f2).member == Set())</p>
<p>// test play<br />
val a1 = play(a)(f1)<br />
assert(a1.member == Set(f1))</p>
<p>println(&quot;ok!&quot;)<br />
[/sourcecode]</p>
<p>Note that the factory method provided by the <em>Account</em> builder include default parameters as well. These default parameters are defined through the <em>Default</em> type class. The companion object of this type class comes equipped with default values for common Scala types, but you can also provide default values for your own specific types. As you can see, the default value defined for types <em>Set[_] </em>is the empty set.</p>
<p>Concerning the rest of the snippet, we also illustrated the use of the '+=' and '-=' operators. Basically, these operators allow the programmer to specify updates of multivalued attributes specifying only just the element to be added or removed to the collection. To be able to use these operators, the<em> </em>type constructor of the attribute type must implement the <em>Modifi</em><em>able </em>type class. Currently, the updatable package offers modifiable instances for <em></em><em>Option </em>and <em></em>any kind of <em>Traversable.</em></p>
<h2>... <strong><em>But be careful with non-"final" attributes</em></strong></h2>
<p>Let's suppose that we changed slightly the signature of the <em>play</em> method:</p>
<p>[sourcecode language="scala"]<br />
def playAll[I &lt;: Interaction: Builder](i: I)(ags: Set[i.Member]): I =<br />
  i.member := ags<br />
[/sourcecode]</p>
<p>Is this type-safe? Certainly not, since the actual type <em>I </em>may have refined the <em>member </em>attribute to a proper <em>Set </em>subtype. For instance, actual type <em>I </em>may have overridden the <em>member </em>declaration to a <em>ListSet,</em> while actual argument <em>ags </em>may be a <em>HashSet. </em>The source of this problem is that the <em>member</em> <em></em>attribute is not "final", in the sense that it can be overridden. We will consider an attribute as "final" if every component which is part of its declared type is a final class or refers to an abstract type.</p>
<p>We may have forbidden non-final attributes to be used as part of update sentences, but this would rule out the above implementation of the <em>play method</em>, which is perfectly safe: in that case, there was no problem because the '+' operator is defined by the different subtypes of the trait <em>Set</em><em>. </em>So, we ended up deciding to just emit a warning if non-final attributes are used by updating sentences <em>in a generic context</em>. If you want to eliminate that warning, you can always make the attribute declaration final with the help of new auxiliary abstract types. For instance, look at the following snippet: the <em>member</em> declaration now refers to a new abstract type <em>MemberCol[_]</em>, which forces us to change the declaration of the <em>playAll </em>method in such a way that the actual type of the attribute must now be taken into account.</p>
<p>[sourcecode language="scala"]<br />
trait Interaction {<br />
  type MemberCol[x] &lt;: Set[x]<br />
  type Member &lt;: Agent<br />
  val member: MemberCol[Member]<br />
}</p>
<p>def playAll[I &lt;: Interaction: Builder](i: I)(ags: i.MemberCol[i.Member]): I =<br />
  i.member := ags<br />
[/sourcecode]</p>
<p><strong>UPDATE: </strong>the above snippet has been changed to fix a mistake detected by Eugene Burmako. Thanks Eugene!</p>
<h2><strong><em>In hindsight ...</em></strong></h2>
<p>We spent a considerable amount of time in the design and implementation of the updatable package, but it was worth it. The <em>Speech </em>layer is populated by several abstract types with dozens of standard attributes, and making the application programmer to provide getters and setters for them, for each of the application types, is a tough work.</p>
<p>But we also found the updatable library useful for other parts of the Speech platform: for instance, we exploit it to facilitate the serialization of JSON objects, so that we can automatically generate a serializer for buildable types (i.e. instances of the <em>Builder </em>type class). We will tell you about this and other applications of the updatable package in following posts, paying particular attention to macro issues.</p>
<p>But there is still a lot that could be done ... besides fixing bugs, of course ;). For instance, we currently require traits to have all of its type members defined in order to generate a builder for it, and it would be nice to relax this constraint. Also, we may extend the updating operator := to cope with nested updates (similarly to what you can achieve with lenses). And we may add support for Union-like types, try to use type macros, etc. We warmly welcome any comment, suggestion for new functionality, corrections, ... and any other kind of help. Enjoy it!</p>
