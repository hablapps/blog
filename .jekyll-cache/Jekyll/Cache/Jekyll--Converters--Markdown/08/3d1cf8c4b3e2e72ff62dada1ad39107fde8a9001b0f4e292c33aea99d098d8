I"Ãd<p>As Dan Piponi suggested in <a href="http://blog.sigfpe.com/2014/05/cofree-meets-free.html">Cofree Meets Free</a>, we may think of <em>coalgebraic things</em> as machines with buttons. In this post, we take this metaphor seriously and show how we can use algebras to model the Input/Output interface of the machine, i.e. its buttons. Prior to that, we‚Äôll make a brief introduction on coalgebras as they are usually shown, namely as F-coalgebras.</p>

<h2 id="what-are-f-coalgebras">What are F-coalgebras?</h2>
<p><em>F-coalgebra</em> (or functor-coalgebra) is just a reversed version of the more popular concept of <a href="https://www.schoolofhaskell.com/user/bartosz/understanding-algebras"><em>F-algebra</em></a>, both of them belonging to the mystical world of Category Theory. The most widespread representation of an F-algebra is</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Algebra</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">X</span>
</code></pre></div></div>

<p>(using <em>Scala</em> here) Paraphrasing Bartosz Milewski, ‚ÄúIt always amazes me how much you can do with so little‚Äù. I believe that its dual counterpart</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Coalgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">X</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
</code></pre></div></div>

<p>deserves the very same amazingness, so today we‚Äôll put focus on them.</p>

<p>Given the previous representation, we notice that F-coalgebras are composed of a carrier <code class="language-plaintext highlighter-rouge">X</code>, a functor <code class="language-plaintext highlighter-rouge">F[_]</code> and a structure <code class="language-plaintext highlighter-rouge">X =&gt; F[X]</code> itself. What can we do with such a thing? Since we are just software developer muggles (vs matemagicians), we need familiar abstractions to deal with coalgebras. Therefore, we like to think of them as machines with buttons, which know how to forward a particular state (maybe requiring some input) to the next one (maybe attaching some output along) by pressing the aforementioned buttons. Now, let‚Äôs find out some examples of mainstream machines that we, as functional programmers, already know:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Generator Machine (Streams)</span>
<span class="k">type</span> <span class="kt">GeneratorF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">S</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Generator</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span><span class="err">¬†</span> <span class="k">=</span> <span class="nc">Coalgebra</span><span class="o">[</span><span class="kt">GeneratorF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span>

<span class="c1">// Mealy Automata Machine</span>
<span class="k">type</span> <span class="kt">AutomataF</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="n">I</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Boolean</span><span class="o">,</span> <span class="n">S</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Automata</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">S</span><span class="o">]</span><span class="err">¬†</span> <span class="k">=</span> <span class="nc">Coalgebra</span><span class="o">[</span><span class="kt">AutomataF</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span>

<span class="c1">// Lens Machine</span>
<span class="k">type</span> <span class="kt">LensF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span><span class="err">¬†</span> <span class="k">=</span> <span class="nc">Coalgebra</span><span class="o">[</span><span class="kt">LensF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span>
</code></pre></div></div>

<p>Firstly, let‚Äôs expand <code class="language-plaintext highlighter-rouge">Generator[A, S]</code> into <code class="language-plaintext highlighter-rouge">S =&gt; (A, S)</code> which is something easier to deal with. Indeed, it‚Äôs just a function that, given an initial state <code class="language-plaintext highlighter-rouge">S</code>, it returns both the head <code class="language-plaintext highlighter-rouge">A</code> and the tail <code class="language-plaintext highlighter-rouge">S</code> associated to that original state. It‚Äôs the simplest specification of a generator machine that one could find! Given a concrete specification and once provided an initial state, we could build a standard <code class="language-plaintext highlighter-rouge">Stream</code> of <code class="language-plaintext highlighter-rouge">A</code>s.</p>

<p>Secondly, we showed a Mealy <code class="language-plaintext highlighter-rouge">Automata</code>. Again, let‚Äôs turn <code class="language-plaintext highlighter-rouge">Automata[I, S]</code> into <code class="language-plaintext highlighter-rouge">S =&gt; I =&gt; (Boolean, S)</code> to see it clearer: given the current state <code class="language-plaintext highlighter-rouge">S</code> and any input <code class="language-plaintext highlighter-rouge">I</code> we can determine both the finality <code class="language-plaintext highlighter-rouge">Boolean</code> condition and the new state <code class="language-plaintext highlighter-rouge">S</code>.</p>

<p>Finally, we saw <code class="language-plaintext highlighter-rouge">Lens</code>. Notice that the type parameters are reversed if we compare this lens with the ‚Äúofficial‚Äù representation (eg. <em>lens</em>, <em>Monocle</em>, etc.). This is just to provide homogeneity with the rest of machines, where the state <code class="language-plaintext highlighter-rouge">S</code> is kept as the last parameter. As usual, let‚Äôs expand <code class="language-plaintext highlighter-rouge">Lens[A, S]</code> to obtain <code class="language-plaintext highlighter-rouge">S =&gt; (A, A =&gt; S)</code>. This tell us that given an initial state <code class="language-plaintext highlighter-rouge">S</code>, we could either <em>get</em> the smaller piece <code class="language-plaintext highlighter-rouge">A</code> or <em>set</em> the whole state with a brand new <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p>So far, we have seen the typical representation for some prominent coalgebras. On the other hand, we claimed that we like to think of those coalgebras as machines with buttons that let us make them work. That machine abstraction seems nice, but I agree it‚Äôs difficult to see those buttons right now. So, let‚Äôs find them!</p>

<h2 id="coalgebras-as-machines-then-show-me-the-buttons">Coalgebras as machines? Then, show me the buttons!</h2>
<p>As promised, we‚Äôll dive into F-coalgebras to find some buttons. I anticipate that those buttons are kind of special, since they could require some input in order to be pressed and they could return some output after that action. We‚Äôre going to use <code class="language-plaintext highlighter-rouge">Lens</code> as a guiding example but we‚Äôll show the final derivation for our three machines at the end as well. So, we start from this representation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">))</span>
</code></pre></div></div>

<p>If we apply basic math, we can split this representation into a tuple, getting an isomorphic one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">S</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div></div>

<p>Trust me when I say that every element in this tuple corresponds with an input-output button, but we still have to make them uniform. First of all, we‚Äôre going to flip the function at the second position, so the input for that button stays in the left hand side:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">S</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div></div>

<p>Our button at the first position has no input, but we can create an artificial one to make the input slot uniform:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Unit</span> <span class="k">=&gt;</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">)</span>
</code></pre></div></div>

<p>Once provided the input for the buttons, we reach different situations. On the first button there is <code class="language-plaintext highlighter-rouge">S =&gt; A</code> which is a kind of observation where the state remains as is. However, in the second button, there is <code class="language-plaintext highlighter-rouge">S =&gt; S</code> which is clearly a state transformation with no output attached to it. If we return the original state along with the observed output in the first button and provide an artificial output for the second one, we get our uniform buttons, both with an input, an output and the resulting state.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Unit</span> <span class="k">=&gt;</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">A</span><span class="o">),</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">S</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="nc">Unit</span><span class="o">))</span>
</code></pre></div></div>

<p>If we squint a bit, we can find an old good friend hidden in the right hand side of our buttons, the <em>State</em> monad, leading us to a new representation where both tuple elements are <em>Kleisli</em> arrows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Unit</span> <span class="k">=&gt;</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Unit</span><span class="o">])</span>
</code></pre></div></div>

<p>Finally, we can achieve a final step, aiming at both naming the buttons and being closer to an object-oriented mindset:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So here we are! We have turned an F-coalgebra into a trait that represents a machine where buttons (get &amp; set) are certainly determined. Obviously, pressing a button is synonym for invoking a method belonging to that machine. The returning value represents the state transformation that we must apply over the current state to make it advance. If we apply the same derivation to streams and automata we get similar representations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Generator</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">head</span><span class="o">()</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">tail</span><span class="o">()</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Automata</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">next</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We‚Äôre glad we found our buttons, so we can reinforce the machine intuition, but <em>stranger things</em> have happened along the way‚Ä¶ The coalgebraic <em>Upside Down</em> world is not quite far from the algebraic one.</p>

<h2 id="buttons-are-algebras">Buttons are Algebras</h2>
<p>In the previous section we made a derivation from the Lens F-coalgebra to a trait Lens where buttons are made explicit. However, that representation was mixing state and input-output concerns. If we go a step further, we can decouple both aspects by abstracting the state away from the specification, to obtain:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">LensAlg</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="nf">set</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="nc">LensAlg</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>So, lenses can be understood as a state-based interpretation of a particular Input/Output algebra. We can distinguish in this kind of specification between two components: the IO interface and the state transition component. Why would we want to define our lenses, or any other coalgebra, in this way? One advantage is that, once we get this representation, where input-output buttons are completely isolated, we can make machine programs that are completely decoupled from the state component, and just depend on the input-output interface. Take <em>modify</em>, a standard lens method, as an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">modify</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
    <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)(</span><span class="k">implicit</span>
    <span class="n">P</span><span class="k">:</span> <span class="kt">LensAlg</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">P</span><span class="o">],</span>
    <span class="n">M</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">P</span><span class="o">.</span><span class="py">get</span> <span class="o">&gt;&gt;=</span> <span class="o">(</span><span class="nv">P</span><span class="o">.</span><span class="py">set</span> <span class="n">compose</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<p>Notice that although <code class="language-plaintext highlighter-rouge">modify</code> constrains <code class="language-plaintext highlighter-rouge">P</code> to be monadic, this restriction could be different in other scenarios, as we can see with <code class="language-plaintext highlighter-rouge">gets</code>, where <code class="language-plaintext highlighter-rouge">Functor</code> is powerful enough to fulfil the programmer needs:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">gets</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
    <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span>
    <span class="n">P</span><span class="k">:</span> <span class="kt">LensAlg</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">P</span><span class="o">],</span>
    <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">P</span><span class="o">.</span><span class="py">get</span> <span class="n">map</span> <span class="n">f</span>
</code></pre></div></div>

<p>These programs are absolutely declarative since nothing has been said about <code class="language-plaintext highlighter-rouge">P[_]</code> yet, except for the fundamental constraints. Indeed, this way of programming should be pretty familiar for a functional programmer: the step that abstracted the state away led us to a (Higher Kinded) <a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">object-algebra</a> interface, which is just an alternative way of representing algebras (as F-algebras are).</p>

<h2 id="ongoing-work">Ongoing Work</h2>
<p>We started this post talking about F-coalgebras, <code class="language-plaintext highlighter-rouge">type Coalgebra[F[_], X] = X =&gt; F[X]</code>, and then we turned our lens coalgebra example into a new representation where buttons and state transformation concerns are clearly identified (rather than being hidden into the functor ‚ÄòF‚Äô). Indeed, we may tentatively put forward IO-coalgebras as a particular class of coalgebras, and define lenses as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">IOCoalgebra</span><span class="o">[</span><span class="kt">IOAlg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">Step</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IOAlg</span><span class="o">[</span><span class="kt">Step</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">?</span><span class="o">]]</span>
<span class="k">type</span> <span class="kt">Lens</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IOCoalgebra</span><span class="o">[</span><span class="kt">LensAlg</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">State</span>, <span class="kt">S</span><span class="o">]</span>
</code></pre></div></div>

<p>As we said in the previous section, this representation empowers us to use the existing algebraic knowledge to deal with coalgebras. So, although we started our journey aiming at the specification of machines, we were brought back to the algebraic world! So, which is the connection between both worlds? In principle, what we suggest is that coalgebras might be viewed as state-based interpretations of algebras. Now, whether any F-Coalgebra can be represented as an IO-Coalgebra is something that has to be shown. And, additionally, we should also identify the constraints in the IOCoalgebra definition that allows us to prove that the resulting formula is actually a coalgebra.</p>

<p>On future posts, we‚Äôll be talking about cofree coalgebras as universal machines. As we will see, those cofree machines exploit the button intuition to simulate any other machine in different contexts. By now, we‚Äôd be really grateful to receive any kind of feedback to discuss the proposed connection between languages and machines. Hope you enjoyed reading!</p>

:ET